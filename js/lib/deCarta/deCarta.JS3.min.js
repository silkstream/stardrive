(function (G, C) {
    var H = G.document;
    var D = {};
    D.geId = function (J) {
        return H.getElementById(J)
    };
    D.crEl = function (J) {
        return H.createElement(J)
    };
    if (!D) {
        var D = {}
    }
    D.Core = {
        modules: [],
        loadModule: function (K, L) {
            if (this.modules[K]) {
                L()
            }
            var J = H.createElement("script");
            J.onload = this.moduleLoaded.bind(this, K, L);
            J.src = "modules/" + K + ".js";
            H.body.appendChild(J)
        },
        moduleLoaded: function (J, K) {
            this.modules[J] = true;
            K()
        }
    };
    D.UI = {};
    var I = D.Core;
    var A = D.UI;
    D.Utilities = {
        setCookie: function (J, M, K) {
            var N = new Date();
            N.setDate(N.getDate() + K);
            var L = escape(M) + ((K == null) ? "" : "; expires=" + N.toUTCString());
            H.cookie = J + "=" + L
        },
        getCookie: function (K) {
            var L, J, N, M = H.cookie.split(";");
            for (L = 0; L < M.length; L++) {
                J = M[L].substr(0, M[L].indexOf("="));
                N = M[L].substr(M[L].indexOf("=") + 1);
                J = J.replace(/^\s+|\s+$/g, "");
                if (J == K) {
                    return unescape(N)
                }
            }
        },
        isArray: function (J) {
            return Object.prototype.toString.call(J) === "[object Array]"
        },
        makeArrayFix: function (J) {
            return D.Utilities.isArray(J) ? J : [J]
        },
        lat2pix: function (L, J) {
            var K = D.Utilities["lat2pix_" + D.Core.Configuration.projection.replace(":", "")];
            if (!K) {
                throw ("Bad projection in the config! This is extremely bad.")
            }
            return K(L, J)
        },
        lat2pix_EPSG3395: function (O, M) {
            var L = 2 * Math.PI / (D.Utilities.tileSizeForZoom(M) * Math.pow(2, Math.floor(M)));
            var P = (parseFloat(O) * (2 * Math.PI)) / 360;
            var K = 0.08181919084262157;
            var J = Math.sin(P);
            var Q = K * J;
            var N = Math.log(((1 + J) / (1 - J)) * Math.pow((1 - Q) / (1 + Q), K)) / 2;
            return (N / L)
        },
        lat2pix_EPSG3857: function (K, J) {
            return D.Utilities.forwardMercator(K, 0, J).y
        },
        lat2pix_Spherical: function (K, J) {
            return D.Utilities.forwardMercator(K, 0, J).y
        },
        forwardMercator: function (M, N, L) {
            var K = (D.Utilities.tileSizeForZoom(L) * Math.pow(2, Math.floor(L - 1)));
            var J = N * K / 180;
            var O = Math.log(Math.tan((90 + M) * Math.PI / 360)) / (Math.PI / 180);
            O = O * K / 180;
            return {
                x: J,
                y: O
            }
        },
        inverseMercator: function (K, O, L) {
            var J = (D.Utilities.tileSizeForZoom(L) * Math.pow(2, Math.floor(L - 1)));
            var N = (K / J) * 180;
            var M = (O / J) * 180;
            M = 180 / Math.PI * (2 * Math.atan(Math.exp(M * Math.PI / 180)) - Math.PI / 2);
            return new D.Core.Position(M, N)
        },
        lon2pix: function (L, K) {
            var J = 2 * Math.PI / (D.Utilities.tileSizeForZoom(K) * Math.pow(2, Math.floor(K)));
            return ((L / 180) * Math.PI) / J
        },
        pix2lon: function (J, L) {
            var K = 2 * Math.PI / (D.Utilities.tileSizeForZoom(L) * Math.pow(2, Math.floor(L)));
            return ((J * K) * 180 / Math.PI)
        },
        pix2lat: function (L, J) {
            var K = D.Utilities["pix2lat_" + D.Core.Configuration.projection.replace(":", "")];
            if (!K) {
                throw ("Bad projection in the config! This is extremely bad.")
            }
            return K(L, J)
        },
        pix2lat_EPSG3395: function (M, Q) {
            var P = 2 * Math.PI / (D.Utilities.tileSizeForZoom(Q) * Math.pow(2, Math.floor(Q)));
            var L = 1e-7;
            var J = 12;
            var R = Math.pow(Math.E, -M * P);
            var N = D.Utilities.mercatorUnproject(R);
            var K = D.Utilities.findRadPhi(N, R);
            var O = 0;
            while (O < J && Math.abs(N - K) > L) {
                N = K;
                K = D.Utilities.findRadPhi(N, R);
                O++
            }
            return K * 180 / Math.PI
        },
        pix2lat_EPSG3857: function (K, J) {
            return D.Utilities.inverseMercator(0, K, J).getLat()
        },
        pix2lat_Spherical: function (K, J) {
            return D.Utilities.inverseMercator(0, K, J).getLat()
        },
        metersPerPixelAtZoom: function (J, M) {
            var L = 156543.04;
            var K = L * Math.cos(J.lat * (Math.PI / 180)) / (Math.pow(2, M));
            return K
        },
        mercatorUnproject: function (J) {
            return (Math.PI / 2) - 2 * Math.atan(J)
        },
        findRadPhi: function (L, K) {
            var J = 0.08181919084262157;
            var M = J * Math.sin(L);
            return (Math.PI / 2) - (2 * Math.atan(K * Math.pow((1 - M) / (1 + M), J / 2)))
        },
        deCartaToGXZoomLevel: function (K) {
            var J = Math.abs(21 - parseInt(D.Utilities.normalizeZoom(K), 10));
            return J
        },
        tileSizeForZoom: function (L, N) {
            if (!this._dpr) {
                this._dpr = D.Window.getDpr()
            }
            var K = this._dpr;
            if (!N) {
                N = D.Core.Constants.TILE_SIZE / K
            }
            var M = N;
            var J = L - Math.floor(L);
            return M * Math.pow(2, J)
        },
        getTilePosition: function (N, Q, P) {
            try {
                var L = D.Core.Constants._ll_LUT[D.Core.Configuration.projection][Math.floor(P)].split(",");
                var J = (N) * L[1];
                var O = D.Utilities.tileSizeForZoom(P) * (Q + 1);
                var M = D.Utilities.pix2lat(O, P);
                return new D.Core.Position(M, J)
            } catch (K) {
                console.log("GetTilePos", K)
            }
        },
        getPointDistance: function (V, U) {
            var L = V.getLat();
            var K = U.getLat();
            var O = V.getLon();
            var N = U.getLon();
            var M = 6378.137;
            var Q = (K - L).toRad();
            var J = (N - O).toRad();
            var T = Math.sin(Q / 2) * Math.sin(Q / 2) + Math.cos(L.toRad()) * Math.cos(K.toRad()) * Math.sin(J / 2) * Math.sin(J / 2);
            var S = 2 * Math.atan2(Math.sqrt(T), Math.sqrt(1 - T));
            var P = M * S;
            return P
        },
        getAngle: function (L, K, J) {
            var N = L.getX(21);
            var P = L.getY(21);
            var M = K.getX(21);
            var O = K.getY(21);
            var Q = Math.atan2(O - P, M - N);
            if (J) {
                return Q
            }
            return ((Q * 180 / Math.PI) + 360) % 360
        },
        getAnglePx: function (Q, P, J) {
            var L = Q.x;
            var N = Q.y;
            var K = P.x;
            var M = P.y;
            var O = Math.atan2(M - N, K - L);
            if (J) {
                return O
            }
            return ((O * 180 / Math.PI) + 360) % 360
        },
        getCenterToFixPositionAtNewZoom: function (T, N, R, S) {
            var J = new D.Core.Position();
            var Q = N.getX(R);
            var P = N.getY(R);
            var L = T.getX(R);
            var K = T.getY(R);
            var O = L - Q;
            var M = K - P;
            J.setXY(T.getX(S) - O, T.getY(S) - M, S);
            return J
        },
        bestZoomForBB: function (J, S, M) {
            for (var P = 20; P > 0; P--) {
                var L = S.getX(P);
                var R = S.getY(P);
                var K = M.getX(P);
                var Q = M.getY(P);
                var O = Math.abs(K - L);
                var N = Math.abs(Q - R);
                if (O <= J.width && N <= J.height) {
                    return P
                }
            }
            return P
        },
        getTileKey: function (J, L, K) {
            return D.Utilities.normalizeZoom(K) + "_" + J + "_" + L
        },
        splitTileKey: function (K) {
            var J = K.split("_");
            return {
                x: parseFloat(J[1]),
                y: parseFloat(J[2]),
                z: parseFloat(J[0])
            }
        },
        tripleToQuadKey: function (J, O, N) {
            var L = "";
            for (var K = (1 << (N - 1)); K > 0; K = K >> 1) {
                var M = 0;
                if ((J & K) != 0) {
                    M += 1
                }
                if ((O & K) != 0) {
                    M += 2
                }
                L += M
            }
            return L
        },
        normalizeZoom: function (J) {
            return Math.floor(J)
        },
        normalizeKey: function (L) {
            var K = D.Utilities.splitTileKey(L);
            var J = Math.pow(D.Utilities.normalizeZoom(K.z), 2);
            if (K.x < 0) {
                K.x += J
            }
            K.x = parseFloat(K.x) % J;
            return D.Utilities.getTileKey(K.x, K.y, K.z)
        },
        getRequestId: function () {
            return Math.floor(Math.random() * 10000000)
        },
        urlParse: function (M) {
            var R = {};
            var P = M.split("#")[0].split("?");
            R.baseUrl = P[0];
            R.queryParameters = {};
            var L = {};
            try {
                var K = P[1].split("&");
                for (var N = 0; N < K.length; N++) {
                    var J = K[N].split("=");
                    L[J[0]] = J[1]
                }
            } catch (O) {}
            R.queryParameters = L;
            try {
                P = R.baseUrl.split("://");
                R.proto = P[0];
                var Q = P[1].split("/");
                R.host = Q[0];
                Q[0] = "";
                R.path = Q.join("/")
            } catch (O) {
                R.proto = "unknown"
            }
            return R
        },
        urlCompose: function (J) {
            var N = J.baseUrl + "?";
            var M = true;
            var L = J.queryParameters;
            for (var K in L) {
                if (!M) {
                    N += "&"
                } else {
                    M = false
                }
                N += K + "=" + L[K]
            }
            return N
        },
        removeElementToReinsert: function (L) {
            var J = L.parentNode;
            var M = L.nextSibling;
            J.removeChild(L);
            return function K() {
                if (M) {
                    J.insertBefore(L, M)
                } else {
                    J.appendChild(L)
                }
            }
        },
        setOpacity: function (M, L) {
            var K = (L / 100);
            var J = M.style;
            J.opacity = K;
            J.MozOpacity = (L / 100);
            J.KhtmlOpacity = (L / 100);
            J.filter = "alpha(opacity=" + L + ")";
            return true
        },
        makeRGBA: function (K, L) {
            var N = parseInt(K.substring(1, 3), 16);
            var M = parseInt(K.substring(3, 5), 16);
            var J = parseInt(K.substring(5), 16);
            return "rgba(" + N + "," + M + "," + J + "," + L + ")"
        },
        extendObject: function (M, L) {
            for (var J in L) {
                try {
                    M[J] = L[J]
                } catch (K) {}
            }
            return M
        },
        inherit: function (L, K) {
            for (var J in K) {
                if (!L[J]) {
                    if (typeof L[J] == "Array" || typeof L[J] == "Object") {
                        L[J] = D.Utilities.inherit(L[J], K[J])
                    }
                    L[J] = K[J]
                }
            }
            return L
        },
        domPosition: function (K) {
            var L = 0;
            var J = 0;
            if (K.offsetParent) {
                do {
                    L += K.offsetLeft;
                    J += K.offsetTop
                } while (K = K.offsetParent)
            }
            return {
                top: J,
                left: L
            }
        },
        extendStyle: function (M, L) {
            for (var J in L) {
                try {
                    M[J] = L[J]
                } catch (K) {}
            }
            return M
        },
        fixEvent: function (K) {
            var J = 0;
            var L = 0;
            if (!K) {
                var K = G.event
            }
            if (K.pageX || K.pageY) {
                J = K.pageX;
                L = K.pageY
            } else {
                if (K.clientX || K.clientY) {
                    K.pageX = J = K.clientX + H.body.scrollLeft + H.documentElement.scrollLeft;
                    K.pageY = L = K.clientY + H.body.scrollTop + H.documentElement.scrollTop
                }
            }
            return K
        },
        getClassName: function (K) {
            var M = K.constructor.toString();
            var L = M.indexOf("function ") + 9;
            var J = M.indexOf("(");
            M = M.substring(L, J);
            return M
        },
        addClass: function (K, J) {
            var M = K.className.split(" ");
            for (var L = 0; L < M.length; L++) {
                if (M[L] == J) {
                    return
                }
            }
            K.className += " " + J
        },
        removeClass: function (L, K) {
            var N = L.className.split(" ");
            var J = [];
            for (var M = 0; M < N.length; M++) {
                if (N[M] != K) {
                    J.push(N[M])
                }
            }
            L.className = J.join(" ")
        },
        getComputedStyle: function (J, K) {
            return this.getStyle(J, K);
            var L = null;
            if (H.defaultView && H.defaultView.getComputedStyle) {
                L = H.defaultView.getComputedStyle
            } else {
                if (typeof (H.body.currentStyle) !== "undefined") {
                    L = function (N, M) {
                        return N.currentStyle
                    }
                }
            }
            alert(J + " " + K);
            return L(J, null)[K]
        },
        getStyle: function (K, J) {
            var L = "";
            if (H.defaultView && H.defaultView.getComputedStyle) {
                L = H.defaultView.getComputedStyle(K, "").getPropertyValue(J)
            } else {
                if (K.currentStyle) {
                    J = J.replace(/\-(\w)/g, function (M, N) {
                        return N.toUpperCase()
                    });
                    L = K.currentStyle[J]
                }
            }
            return L
        },
        getStyleFromCssName: function (J) {
            if (J.charAt(0) != ".") {
                J = "." + J
            }
            for (var K = 0; K < H.styleSheets.length; K++) {
                if (H.styleSheets[K]) {
                    var L = H.styleSheets[K].cssRules || H.styleSheets[K].rules;
                    console.log(L, H.styleSheets[K]);
                    if (L) {
                        for (j = 0; j < L.length; j++) {
                            if (L[j].selectorText && (L[j].selectorText.toLowerCase() == J.toLowerCase())) {
                                return L[j]
                            }
                        }
                    }
                }
            }
            return {}
        },
        getObjectPosition: function (L) {
            var M = L;
            var N = 0;
            if (L.offsetParent) {
                while (1) {
                    N += L.offsetLeft;
                    if (L.style) {
                        var K = parseFloat(this.getStyle(L, "border-left-width"));
                        if (K) {
                            N += K
                        }
                    }
                    if (!L.offsetParent) {
                        break
                    }
                    L = L.offsetParent
                }
            } else {
                if (L.x) {
                    N += L.x
                }
            }
            L = M;
            var J = 0;
            if (L.offsetParent) {
                while (1) {
                    J += L.offsetTop;
                    if (L.style) {
                        var K = parseFloat(this.getStyle(L, "border-top-width"));
                        if (K) {
                            J += K
                        }
                    }
                    if (!L.offsetParent) {
                        break
                    }
                    L = L.offsetParent
                }
            } else {
                if (L.y) {
                    J += L.y
                }
            }
            return {
                x: N,
                y: J
            }
        },
        domRemove: function (J) {
            J.parentNode.removeChild(J)
        },
        isChild: function (K, J, L) {
            if (!L) {
                L = 0
            }
            if (L > 10) {
                return false
            }
            if (!K) {
                return false
            }
            if (K.parentNode == J) {
                return true
            }
            if (K.parentNode == H.body) {
                return false
            }
            return D.Utilities.isChild(K.parentNode, J, L + 1)
        },
        pixelDistance: function (K, J) {
            return Math.sqrt(Math.pow(K.x - J.x, 2) + Math.pow(K.y - J.y, 2))
        },
        positionPixelDistance: function (L, J, K) {
            return Math.sqrt(Math.pow(L.getX(K) - J.getX(K), 2) + Math.pow(L.getY(K) - J.getY(K), 2))
        },
        podParse: function (K) {
            var N = parseInt(K.substring(K.indexOf("P") + 1, K.indexOf("D")));
            var J = parseInt(K.substring(K.indexOf("T") + 1, K.indexOf("H")));
            var L = parseInt(K.substring(K.indexOf("H") + 1, K.indexOf("M")));
            var M = parseInt(K.substring(K.indexOf("M") + 1, K.indexOf("S")));
            if (N > 0) {
                return ((N * 24) + J) + " hours " + L + " minutes "
            } else {
                if (J > 0) {
                    return J + " hours " + L + " minutes "
                } else {
                    if (L > 0) {
                        return L + " minutes " + M + " seconds "
                    } else {
                        return M + " seconds"
                    }
                }
            }
        },
        podParseJSON: function (K) {
            var N = parseInt(K.substring(K.indexOf("P") + 1, K.indexOf("D")));
            var M = parseInt(K.substring(K.indexOf("T") + 1, K.indexOf("H")));
            var J = parseInt(K.substring(K.indexOf("H") + 1, K.indexOf("M")));
            var L = parseInt(K.substring(K.indexOf("M") + 1, K.indexOf("S")));
            return {
                days: N,
                hours: M,
                minutes: J,
                seconds: L
            }
        },
        LatLonToMercator: function (lat, lon) {
            var rMajor = 6378137; //Equatorial Radius, WGS84
            var shift = Math.PI * rMajor;
            var x = lon * shift / 180;
            var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
            y = y * shift / 180;
            return { 'X': x, 'Y': y };
        },
        calcMercator_BBOX: function (x, y, zoom) {
            //bottomLeft to TopRight
            var BBOX = "";
            var p1 = this.getTilePosition(x, y, zoom);
            var x = p1.getX(zoom);
            var y = p1.getY(zoom);
            var p2 = new deCarta.Core.Position(0, 0);
            p2.setXY(x + 256, y - 256, zoom);

            //lat/lon to pix
            //    var latPix = deCarta.Utilities.lat2pix(pos.getLat(), z);
            //    var lonPix = deCarta.Utilities.lon2pix(pos.getLon(), z);
            //    var mpp = deCarta.Utilities.metersPerPixelAtZoom(pos, z);
            //    var latPix1 = latPix + (deCarta.App.map.height / 2);
            //    var lonPix1 = lonPix - (deCarta.App.map.width / 2);
            //    var latPix2 = latPix - (deCarta.App.map.height / 2);
            //    var lonPix2 = lonPix + (deCarta.App.map.width / 2);
            //    var newY1 = deCarta.Utilities.pix2lat(latPix1, z);
            //    var newX1 = deCarta.Utilities.pix2lon(lonPix1, z);
            //    var newY2 = deCarta.Utilities.pix2lat(latPix2, z);
            //    var newX2 = deCarta.Utilities.pix2lon(lonPix2, z);
            var XY1 = this.LatLonToMercator(p1.getLat(), p1.getLon());
            var XY2 = this.LatLonToMercator(p2.getLat(), p2.getLon());
            //var trafBox = XY1.Y + "," + XY1.X + "," + XY2.Y + "," + XY2.X;
            //var trafBox = XY1.X + "," + XY2.Y + "," + XY2.X + "," + XY1.Y;
            var trafBox = XY1.X + "," + XY2.Y + "," + XY2.X + "," + XY1.Y;
            //BBOX = p1.getLon() + ',' + p2.getLat() + ',' + p2.getLon() + ',' + p1.getLat();
            return trafBox;
        }
    };
    if (!Function.prototype.bind) {
        Function.prototype.bind = function (L) {
            var M = Array.prototype.slice;

            function O(S, P) {
                var R = S.length,
                    Q = P.length;
                while (Q--) {
                    S[R + Q] = P[Q]
                }
                return S
            }
            function N(Q, P) {
                Q = M.call(Q, 0);
                return O(Q, P)
            }
            if (arguments.length < 2 && (typeof arguments[0] === "Undefined")) {
                return this
            }
            var J = this,
                K = M.call(arguments, 1);
            return function () {
                var P = N(K, arguments);
                return J.apply(L, P)
            }
        }
    }
    if (typeof (String.prototype.toRad) === "undefined") {
        Number.prototype.toRad = function () {
            return this * Math.PI / 180
        }
    }
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (K) {
            var J = this.length >>> 0;
            var L = Number(arguments[1]) || 0;
            L = (L < 0) ? Math.ceil(L) : Math.floor(L);
            if (L < 0) {
                L += J
            }
            for (; L < J; L++) {
                if (L in this && this[L] === K) {
                    return L
                }
            }
            return -1
        }
    }
    G.requestAnimFrame = (function () {
        return G.requestAnimationFrame || G.webkitRequestAnimationFrame || G.mozRequestAnimationFrame || G.oRequestAnimationFrame || G.msRequestAnimationFrame || function (L, J, K) {
            if (!K) {
                K = 1000 / 30
            }
            G.setTimeout(L, K)
        }
    })();
    D.Touch = {
        observedElements: [],
        events: {
            touchstart: "touchstart",
            touchend: "touchend",
            touchmove: "touchmove",
            touchout: "touchout",
            touchover: "touchover",
            tap: "tap",
            doubletap: "doubletap",
            alttap: "alttap",
            longtouch: "longtouch",
            mousedown: "touchstart",
            mouseup: "touchend",
            mousemove: "touchmove",
            mouseout: "touchout",
            mouseover: "touchover",
            hoveron: "touchover",
            hoveroff: "touchout",
            click: "tap",
            doubleclick: "doubletap",
            rightclick: "alttap",
            longclick: "longtouch",
            dragstart: "touchstart",
            dragend: "touchend",
            dragmove: "touchmove",
            dragout: "dragout",
            press: "tap",
            doublepress: "doubletap",
            altpress: "alttap",
            longpress: "longtouch"
        },
        LONG_TAP_TIME: 1500,
        DOUBLE_TAP_TOLERANCE: 10,
        DOUBLE_TAP_TIME: 300,
        MAX_TAP_DISTANCE: 10,
        touchable: /webos|bada|android|blackberry|fennec|ip(hone|od|ad)|maemo|opera mob|Kindle Fire|Silk/i.test(navigator.userAgent || navigator.vendor || G.opera),
        withinDistance: function (L, J, K) {
            return Math.sqrt(Math.pow(L.x - J.x, 2) + Math.pow(L.y - J.y, 2)) <= K
        },
        attachListener: function (M, K, N, J) {
            var L = this.getElement(K);
            L.attachListener(M, N, J)
        },
        removeListener: function (L, J, M) {
            var K = this.getElement(J);
            K.removeListener(L, M)
        },
        getElement: function (K) {
            for (var J = 0; J < this.observedElements.length; J++) {
                if (this.observedElements[J].element == K) {
                    return this.observedElements[J]
                }
            }
            var L = new D.Touch.ObservedElement(K);
            this.observedElements.push(L);
            return this.observedElements[J]
        },
        stopEvent: function (J) {
            try {
                if (J.preventDefault) {
                    J.preventDefault()
                }
                if (J.stopPropagation) {
                    J.stopPropagation()
                }
                J.returnValue = false;
                J.cancelBubble = true
            } catch (J) {}
        }
    };
    D.Touch.ObservedElement = function (K) {
        this.element = K;
        this.preventDefault = false;
        this.listeners = {};
        var J = function (L, N, M) {
            this.x = L;
            this.y = N;
            this.t = M
        };
        this.startPoint = null;
        this.endPoint = null;
        this.lastPoint = null;
        this.longTouchListener = null;
        this.lastTapTime = 0;
        this.lastTapLocation = null;
        this.start = function (M) {
            if (this.preventDefault) {
                if (M) {
                    if (M.preventDefault) {
                        M.preventDefault()
                    }
                    M.returnValue = false;
                    M.cancelBubble = true
                }
            }
            var L = this.normalizeEvent(M);
            if (M.touches && M.touches.length == 2) {
                this.startTouchDistance = D.Utilities.pixelDistance({
                    x: M.touches[0].pageX,
                    y: M.touches[0].pageY
                }, {
                    x: M.touches[1].pageX,
                    y: M.touches[1].pageY
                })
            }
            this.trigger("touchstart", L, M);
            this.startPoint = new J(L.pageX, L.pageY, new Date().getTime());
            this.lastPoint = this.startPoint;
            this.longTouchListener = setTimeout(this.longTouch.bind(this, L), D.Touch.LONG_TAP_TIME)
        };
        this.move = function (P) {
            if (this.preventDefault) {
                if (P) {
                    if (P.preventDefault) {
                        P.preventDefault()
                    }
                    P.returnValue = false;
                    P.cancelBubble = true
                }
            }
            var N = this.normalizeEvent(P);
            var R = (P.scale || 1);
            N.rotation = (P.rotation || 0);
            if (R == 1 && P.touches && P.touches.length == 2 && (G.opera || G.PalmSystem)) {
                var Q = D.Utilities.pixelDistance({
                    x: P.touches[0].pageX,
                    y: P.touches[0].pageY
                }, {
                    x: P.touches[1].pageX,
                    y: P.touches[1].pageY
                });
                R = Q / this.startTouchDistance
            }
            if (R) {
                N.scale = R;
                if (P.touches && P.touches.length > 1) {
                    this.preventDouble = true;
                    var L = 0;
                    var S = 0;
                    for (var M = 0; M < P.touches.length; M++) {
                        L += P.touches[M].pageX;
                        S += P.touches[M].pageY
                    }
                    N.centerX = L / P.touches.length;
                    N.centerY = S / P.touches.length
                }
            }
            if (D.Window.isIe()) {
                N.pageX = (N.clientX + H.documentElement.scrollLeft);
                N.pageY = (N.clientY + H.documentElement.scrollTop)
            }
            this.trigger("touchmove", N, P);
            var O = new J(N.pageX, N.pageY, new Date().getTime());
            this.lastPoint = O
        };
        this.over = function (M) {
            var L = this.normalizeEvent(M);
            this.trigger("touchover", L, M)
        };
        this.out = function (N) {
            var L = N;
            var N = N.relatedTarget || N.toElement || N.originalTarget;
            var M = D.Utilities.isChild(N, this.element);
            if (!M) {
                var L = this.normalizeEvent(N);
                this.trigger("touchout", L, N)
            }
        };
        this.end = function (N) {
            if (this.preventDefault) {
                if (N) {
                    if (N.preventDefault) {
                        N.preventDefault()
                    }
                    N.returnValue = false;
                    N.cancelBubble = true
                }
            }
            var M = this.normalizeEvent(N);
            this.trigger("touchend", M, N);
            this.endPoint = new J(M.pageX, M.pageY, new Date().getTime());
            if (this.preventDouble) {
                setTimeout(function () {
                    this.preventDouble = false
                }.bind(this), D.Touch.DOUBLE_TAP_TIME)
            }
            if (!this.preventDouble && this.lastTapLocation && (new Date().getTime()) - this.lastTapTime < D.Touch.DOUBLE_TAP_TIME) {
                var O = D.Utilities.pixelDistance(this.startPoint, this.endPoint);
                if (O < D.Touch.DOUBLE_TAP_TOLERANCE) {
                    this.lastTapLocation = this.startPoint;
                    var L = D.Utilities.getObjectPosition(this.element);
                    if (this.longTouchListener) {
                        clearInterval(this.longTouchListener);
                        this.longTouchListener = null
                    }
                    this.trigger("doubletap", {
                        relativeX: this.startPoint.x - L.x,
                        relativeY: this.startPoint.y - L.y,
                        pageX: this.startPoint.x - L.x,
                        pageY: this.startPoint.y - L.y
                    }, N);
                    return
                }
            }
            if (this.longTouchListener) {
                clearInterval(this.longTouchListener);
                this.longTouchListener = null;
                this.lastTapLocation = this.startPoint;
                this.lastTapTime = new Date().getTime();
                if (D.Touch.withinDistance(this.startPoint, this.lastPoint, 3)) {
                    if (N.button && N.button == 2) {
                        this.trigger("alttap", M, N)
                    } else {
                        this.trigger("tap", M, N)
                    }
                }
                return
            }
        };
        this.longTouch = function (M) {
            if (D.Touch.withinDistance(this.startPoint, this.lastPoint, D.Touch.MAX_TAP_DISTANCE)) {
                if (this.longTouchListener != null) {
                    this.longTouchListener = null;
                    var L = D.Utilities.getObjectPosition(this.element);
                    var N = {
                        relativeX: this.startPoint.x - L.x,
                        relativeY: this.startPoint.y - L.y,
                        pageX: this.startPoint.x - L.x,
                        pageY: this.startPoint.y - L.y
                    };
                    this.trigger("longTouch", N, M)
                }
            } else {
                this.longTouchListener = null
            }
        };
        this.normalizeEvent = function (N) {
            if (!N) {
                return
            }
            var O = null;
            try {
                if (N.targetTouches && N.targetTouches[0]) {
                    O = D.Utilities.extendObject({}, N.targetTouches[0])
                } else {
                    O = D.Utilities.extendObject({}, N)
                }
            } catch (M) {
                O = D.Utilities.extendObject({}, N)
            }
            if (O.type == "touchend") {
                O.pageX = this.lastPoint.x;
                O.pageY = this.lastPoint.y
            }
            var L = D.Utilities.getObjectPosition(this.element);
            if (D.Window.isIe()) {
                O.pageX = (O.clientX + H.documentElement.scrollLeft);
                O.pageY = (O.clientY + H.documentElement.scrollTop);
                O.relativeY = O.pageY - L.y;
                O.relativeX = O.pageX - L.x
            } else {
                O.relativeY = O.pageY - L.y;
                O.relativeX = O.pageX - L.x
            }
            return D.Utilities.extendObject({}, O)
        };
        this.attachListener = function (M, N, L) {
            if (!D.Touch.events[M.toLowerCase()]) {
                throw ("Unknown event : " + M + ". What are you trying to do? Think carefully!")
            }
            M = D.Touch.events[M.toLowerCase()].toLowerCase();
            if (!this.preventDefault) {
                this.preventDefault = L
            }
            if (!this.listeners[M]) {
                this.listeners[M] = []
            }
            this.listeners[M].push({
                listener: N,
                preventDefault: L
            })
        };
        this.removeListener = function (M, N) {
            if (!this.listeners[M]) {
                return
            }
            for (var L = 0; L < this.listeners[M].length; L++) {
                if (this.listeners[M][L].listener == N) {
                    this.listeners[M].splice(L, 1)
                }
            }
        };
        this.trigger = function (M, O, L) {
            M = M.toLowerCase();
            if (this.listeners[M]) {
                for (var N = 0; N < this.listeners[M].length; N++) {
                    this.listeners[M][N].listener(O, L)
                }
            }
        };
        this.attach = function (N, M, L) {
            if (D.Window.isIe()) {
                this.element.attachEvent("on" + N, M)
            } else {
                this.element.addEventListener(N, M, L)
            }
        };
        if (D.Touch.touchable) {
            this.attach("touchstart", this.start.bind(this), false);
            this.attach("touchend", this.end.bind(this), false);
            this.attach("touchmove", this.move.bind(this), false)
        } else {
            this.attach("mousedown", this.start.bind(this), false);
            this.attach("mouseup", this.end.bind(this), false);
            this.attach("mousemove", this.move.bind(this), false)
        }
        this.attach("mouseover", this.over.bind(this), false);
        this.attach("mouseout", this.out.bind(this), false)
    };
    D.Window = {
        isTouchable: function () {
            return D.Touch.touchable
        },
        isMobile: function () {
            return /bada|android|blackberry|fennec|ip(hone|od|ad)|maemo|opera mob/i.test(navigator.userAgent || navigator.vendor || G.opera)
        },
        isBada: function () {
            return /bada/i.test(navigator.userAgent || navigator.vendor || G.opera)
        },
        isIOS: function () {
            return /ip(hone|od|ad)/i.test(navigator.userAgent || navigator.vendor || G.opera)
        },
        isSafari: function () {
            return /Safari/i.test(navigator.userAgent || navigator.vendor || G.opera)
        },
        isAndroid: function () {
            return /deviceAndroid/i.test(navigator.userAgent || navigator.vendor || G.opera)
        },
        isIe: function () {
            if (H.all) {
                return true
            }
        },
        isChrome: function () {
            return navigator.userAgent.toLowerCase().indexOf("chrome") > -1
        },
        isFirefox: function () {
            return navigator.userAgent.indexOf("Firefox") != -1
        },
        hasCSSTransforms: function () {
            return (D.Window.isChrome() || D.Window.isIOS())
        },
        hasSVG: function () {
            if (typeof this.svgSupport == "undefined") {
                this.svgSupport = H.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")
            }
            return this.svgSupport
        },
        hasVML: function () {
            if (typeof this.vmlSupport == "undefined") {
                var K = H.body.appendChild(H.createElement("div"));
                K.innerHTML = '<v:shape id="vml_flag1" adj="1" />';
                var J = K.firstChild;
                J.style.behavior = "url(#default#VML)";
                this.vmlSupport = J ? typeof J.adj == "object" : true;
                K.parentNode.removeChild(K)
            }
            return this.vmlSupport
        },
        hasCanvas: function () {
            if (typeof this.canvasSupport == "undefined") {
                var J = H.createElement("canvas");
                this.canvasSupport = !! (J.getContext && J.getContext("2d"))
            }
            return this.canvasSupport
        },
        getDpr: function () {
            if (D.Window.dpr) {
                return D.Window.dpr
            }
            if (this.isIe() || !this.isMobile()) {
                D.Window.dpr = 1;
                return D.Window.dpr
            }
            if (/bada/i.test(navigator.userAgent || navigator.vendor || G.opera)) {
                D.Window.dpr = G.outerWidth / G.innerWidth;
                return D.Window.dpr
            }
            if (G.devicePixelRatio) {
                D.Window.dpr = G.devicePixelRatio;
                return D.Window.dpr
            }
            if (H.documentElement.clientWidth != G.innerWidth) {
                D.Window.dpr = Math.floor((G.innerWidth / H.documentElement.clientWidth) * 100) / 100;
                return D.Window.dpr
            }
            if (H.documentElement.clientWidth < 480) {
                D.Window.dpr = 1
            }
            D.Window.dpr = 1;
            return D.Window.dpr
        },
        getViewport: function () {
            if (this.isIe()) {
                return {
                    width: H.body.clientWidth,
                    height: H.body.clientHeight
                }
            }
            var J = this.getDpr();
            if (G.opera) {
                return {
                    width: G.innerWidth,
                    height: Math.ceil(G.outerHeight / J)
                }
            }
            if (/bada/i.test(navigator.userAgent || navigator.vendor)) {
                return {
                    width: G.innerWidth,
                    height: G.innerHeight
                }
            }
            if (G.devicePixelRatio) {
                return {
                    width: G.innerWidth,
                    height: G.innerHeight
                }
            }
            return {
                width: G.innerWidth / J,
                height: G.innerHeight / J
            }
        }
    };
    D.Core.EventableObject = function () {
        this.objectId = "dCObject-" + (Math.random() + "").replace(".", "");
        this.hovered = false;
        this.createEventHooks()
    };
    D.Core.EventableObject.prototype = {
        createEventHooks: function () {
            var K = D.Core.EventManager.eventNames;
            for (var L in K) {
                var J = "on" + L;
                this[J] = function (N, O) {
                    var M = D.Core.EventManager.listen(N, O, this);
                    return function () {
                        D.Core.EventManager.stopListeningByIdx(N, M)
                    }
                }.bind(this, L)
            }
        },
        on: function (M, N) {
            var L = M.split(" ");
            for (var K = 0; K < L.length; K++) {
                var J = "on" + L[K];
                if (typeof this[J] === "function") {
                    this[J](N)
                }
            }
        },
        trigger: function (J, K) {
            D.Core.EventManager.trigger(J, K, this)
        },
        addListeners: function (J, K) {
            D.Touch.attachListener("touchstart", J, this.touchStart.bind(this), K);
            D.Touch.attachListener("touchmove", this.owner.owner.canvas, this.touchMove.bind(this), K);
            D.Touch.attachListener("touchend", this.owner.owner.canvas, this.touchEnd.bind(this), K);
            D.Touch.attachListener("touchout", J, this.touchOut.bind(this), K);
            D.Touch.attachListener("touchover", J, this.touchOver.bind(this), K);
            D.Touch.attachListener("doubleTap", J, this.doubleTap.bind(this), K);
            D.Touch.attachListener("longTouch", J, this.longTouch.bind(this), K);
            D.Touch.attachListener("tap", J, this.tap.bind(this), K);
            D.Touch.attachListener("altTap", J, this.altTap.bind(this), K)
        },
        touchStart: function (J, K) {},
        touchMove: function (J, K) {},
        touchEnd: function (J, K) {},
        touchOut: function (J, K) {
            if (!this.hovered || this.dragging) {
                return
            }
            this.triggerEvent("hoveroff", J, K, true);
            this.hovered = false
        },
        touchOver: function (J, K) {
            if (this.hovered || this.dragging) {
                return
            }
            this.hovered = true;
            this.triggerEvent("hoveron", J, K)
        },
        shouldProcessEvent: function (J) {
            return true
        },
        doubleTap: function (J, K) {
            this.triggerEvent("doubleclick", J, K)
        },
        longTouch: function (J, K) {
            this.triggerEvent("longtouch", J, K)
        },
        tap: function (J, K) {
            this.triggerEvent("click", J, K)
        },
        altTap: function (J, K) {
            this.triggerEvent("rightclick", J, K)
        },
        checkEvent: function (L, N) {
            if (this.dragging) {
                return true
            }
            var K = D.Utilities.domPosition(this.owner.owner.canvas);
            var J = L.pageX - K.left - this.domX;
            var M = L.pageY - K.top - this.domY;
            return this.shouldProcessEvent(N, J, M)
        },
        triggerEvent: function (M, O, R, N) {
            var K = D.Utilities.domPosition(this.owner.owner.canvas);
            var Q = O.pageX - K.left;
            var P = O.pageY - K.top;
            var L = this.owner.owner.positionFromXY(Q, P);
            if (!N) {
                if (!this.checkEvent(O, L)) {
                    return
                }
            }
            var J = new D.Core.Event({
                DOMevent: R,
                touchEvent: O,
                position: L
            });
            D.Core.EventManager.trigger(M, J, this)
        }
    };
    D.Core.Event = function (J) {
        this.object;
        this.eventType;
        this.DOMEvent;
        this.position;
        this.center;
        this.zoom;
        this.size;
        D.Utilities.extendObject(this, J)
    };
    D.Core.Map = function (J) {
        D.Core.EventableObject.call(this, J);
        this.type = "map";
        this.options = {
            mode: "html",
            id: null,
            zoom: 3,
            center: new D.Core.Position(37.689107, -122.427957),
            onReady: null,
            onError: null,
            easing: true,
            digitalZoom: true,
            layers: null,
            controls: null,
            doubleTapZoom: true,
            draggable: true,
            controlZ: 1000,
            resizeable: true,
            autoResize: true,
            minResizeInterval: 200,
            maxZoom: 19,
            minZoom: 2,
            scrollWheelEnabled: true,
            bindToServerCallback: C,
            skipBindingToServer: false,
            skipResources: false,
            forceResourceSTAGRequest: false,
            boundaries: {
                top: 87,
                bottom: -87,
                left: null,
                right: null
            },
            zoomFramer: new D.Core.ZoomFramer(),
            avoidEvents: false
        };
        this.options = D.Utilities.extendObject(this.options, J);
        this.containerElement = D.geId(J.id);
        this.containerElement.onselectstart = function () {
            return false
        };
        this.containerElement.oncontextmenu = function () {
            return false
        };
        this.containerElement.style.overflow = "hidden";
        if (!this.options.id || !this.containerElement) {
            D.Core.Exception.raise("Map creation failed: no DOM id set in the options, or it is invalid")
        }
        this.canvas = D.crEl("div");
        this.canvas.style.overflow = "hidden";
        this.canvas.className = "deCarta-Mobile-Map";
        this.canvas.style.position = "absolute";
        this.canvas.style.top = 0;
        this.canvas.style.left = 0;
        this.canvas.style.cursor = 'url("' + D.Core.Configuration.imgPath + '/openhand.cur"), auto';
        this.canvas.style.userSelect = "none";
        this.canvas.style.mozUserSelect = "none";
        this.canvas.style.webkitUserSelect = "none";
        this.canvas.style.unselectable = "on";
        this.canvas.style.onselectstart = function () {
            return false
        };
        this.containerElement.appendChild(this.canvas);
        this.topPosition = (this.options.boundaries.top) ? new D.Core.Position(this.options.boundaries.top, 0) : null;
        this.btmPosition = (this.options.boundaries.bottom) ? new D.Core.Position(this.options.boundaries.bottom, 0) : null;
        this.leftPosition = (this.options.boundaries.left) ? new D.Core.Position(0, this.options.boundaries.left) : null;
        this.rightPosition = (this.options.boundaries.right) ? new D.Core.Position(0, this.options.boundaries.right) : null;
        this.panVector = {
            x: 0,
            y: 0,
            v: 0
        };
        this.layers = [];
        this.controls = [];
        this.ofsX = this.ofsY = 0;
        this.zoom = this.options.zoom;
        this.targetZoom = this.options.zoom;
        this.maxZoom = (typeof this.options.maxZoom !== "undefined") ? this.options.maxZoom : 20;
        this.minZoom = (typeof this.options.minZoom !== "undefined") ? this.options.minZoom : 2;
        this.zooming = false;
        this.dragging = false;
        this.easing = false;
        this.dragStartX = this.dragStartY = 0;
        this.lastDragEvent = null;
        this.center = this.options.center;
        this.targetCenter = this.center.clone();
        this.console = D.geId("console");
        this.tileGrid = new D.Core.TileGrid();
        this.owner = this;
        this.needsRender = true;
        this.debugInfo = {
            renderings: 0,
            totalRenderTime: 0,
            skippedRenders: 0,
            moveEvents: 0
        };
        this.ready = false;
        this.infoWindow = new D.Core.InfoWindow(this);
        D.Core.EventManager.listen("tileLoad", function (K) {
            this.render(true)
        }.bind(this), this);
        this.initControls();
        if (this.options.skipBindingToServer) {
            setTimeout(function () {
                this.init()
            }.bind(this), 1)
        } else {
            D.Core.JSRequest.init(function (K) {
                if (K.success) {
                    this.init()
                } else {
                    if (this.options.onError) {
                        this.options.onError(K.msg)
                    }
                    if (!typeof this.options.bindToServerCallback === "function") {
                        D.Core.Exception.raise(K.msg)
                    }
                }
                if (typeof this.options.bindToServerCallback === "function") {
                    this.options.bindToServerCallback(K)
                }
            }.bind(this))
        }
    };
    D.Core.Map.prototype = {
        initControls: function () {
            if (this.ready) {
                this.doneControls()
            } else {
                setTimeout(this.initControls.bind(this), 100)
            }
        },
        doneControls: function () {
            if (this.options.controls) {
                for (var J = 0; J < this.options.controls.length; J++) {
                    this.addControl(this.options.controls[J], true)
                }
            }
            this.drawControls();
            this.resize();
            if (typeof this.options.onImagesLoaded === "function") {
                this.options.onImagesLoaded()
            }
        },
        _getWidth: function () {},
        _getHeight: function () {},
        resize: function () {
            if (this._lastResize && !this.options.autoResize) {
                return
            }
            if (this._lastResize && this.options.autoResize && this.options.minResizeInterval) {
                var J = new Date().getTime();
                if (J < (this._lastResize + this.options.minResizeInterval)) {
                    if (this._resizeTimeout) {
                        clearTimeout(this._resizeTimeout)
                    }
                    this._resizeTimeout = setTimeout(this.resize.bind(this), this.options.minResizeInterval);
                    return
                }
            }
            var K = 0;
            this.width = parseFloat(this.containerElement.style.width);
            this.height = parseFloat(this.containerElement.style.height);
            if (!this.width || !this.height) {
                this.width = parseFloat(this.containerElement.clientWidth);
                this.height = parseFloat(this.containerElement.clientHeight)
            }
            this.canvas.style.width = this.width + "px";
            this.canvas.style.height = this.height + "px";
            if (D.Window.isIe()) {
                G.attachEvent("onresize", this.resize.bind(this))
            } else {
                G.addEventListener("resize", this.resize.bind(this))
            }
            this.tileGrid.resize(this.width, this.height);
            for (K = 0; K < this.layers.length; K++) {
                this.layers[K].resize(this.width, this.height)
            }
            this.triggerEvent("resize");
            this._lastResize = new Date().getTime();
            this.drawControls();
            this.render()
        },
        getHighestZ: function () {
            var J = 0;
            try {
                for (var K = 0; K < this.layers.length; K++) {
                    if (this.layers[K].options.zIndex) {
                        if (this.layers[K].options.zIndex > J) {
                            J = this.layers[K].options.zIndex
                        }
                    }
                }
            } catch (L) {}
            return D.Core.Configuration.baseOvlZ + J
        },
        getInfoWindow: function () {
            return this.infoWindow
        },
        init: function () {
            var J = 0;
            this.baseZoom = this.zoom;
            this.lastTouchTime = 0;
            this.streetLayer = new D.Core.MapLayer({
                name: "Map View",
                visible: true,
                tileStore: new D.Core.StreetTileStore({
                    precache: !D.Window.isMobile()
                })
            });
            this.addLayer(this.streetLayer);
            this.satelliteLayer = new D.Core.MapLayer({
                name: "Satellite View",
                visible: false,
                tileStore: new D.Core.SatelliteTileStore({
                    precache: false
                })
            });
            this.addLayer(this.satelliteLayer);
            this.hybridLayer = new D.Core.MapLayer({
                name: "Hybrid View",
                visible: false,
                tileStore: new D.Core.TransparentTileStore({
                    precache: false
                })
            });
            this.addLayer(this.hybridLayer);
            this.defaultOverlay = new D.Core.MapOverlay({
                name: "Map Data Overlay",
                visible: true
            });
            this.addOverlay(this.defaultOverlay);
            var K = D.crEl("div");
            K.style.width = "1px";
            K.style.height = "1px";
            this.infoWindowAnchor = new D.Core.Pin({
                position: new D.Core.Position(this.center.lat, this.center.lon),
                image: K
            });
            this.defaultOverlay.addObject(this.infoWindowAnchor);
            if (this.options.layers) {
                for (J = 0; J < this.options.layers.length; J++) {
                    this.addLayer(this.options.layers[J])
                }
            }
            if (!this.options.avoidEvents) {
                this.addListeners(this.canvas, true)
            }
            this.count = 0;
            this.triggerEvent("zoomEnd");
            this.resize();
            setTimeout(function () {
                if (!D.Window.isMobile() && this.options.scrollWheelEnabled) {
                    if (this.options.zoomFramer) {
                        this.options.zoomFramer.setOwner(this)
                    }
                }
                this._ready()
            }.bind(this), 1)
        },
        addLayer: function (J) {
            if (!J.render || !J.resize) {
                D.Core.Exception.raise('The layer you are trying to add does not support required methods "render" or "resize".')
            }
            J.setOwner({
                owner: this,
                canvas: this.canvas
            });
            this.layers.push(J);
            return J
        },
        removeLayer: function (K) {
            for (var J = 0; J < this.layers.length; J++) {
                if (this.layers[J] == K) {
                    this.layers.splice(J, 1);
                    return true
                }
            }
            return false
        },
        addOverlay: function (J) {
            return this.addLayer(J)
        },
        removeOverlay: function (J) {
            return this.removeLayer(J)
        },
        setDraggable: function (J) {
            this.options.draggable = J
        },
        setMapStyle: function (J) {
            D.Core.Configuration.defaultConfig = J;
            D.Core.Configuration.defaultHighResConfig = J;
            this.render()
        },
        showTraffic: function (J) {
            D.Core.JSRequest.sessionId = Math.ceil((new Date().getTime()) * Math.random());
            D.Core.Configuration.showTraffic = J;
            this.tileGrid.tiles = [];
            this.render()
        },
        showInfoWin: function (J, L, K) {
            this.infoWindowAnchor.setPosition(J);
            this.infoWindowAnchor.options.text = L;
            if (K) {
                K.content = L;
                this.infoWindowAnchor.options.infoWinOptions = D.Utilities.extendObject(this.infoWindowAnchor.options.infoWinOptions, K)
            }
            this.infoWindowAnchor.showText()
        },
        hideInfoWin: function () {
            if (this.infoWindow.target) {
                this.infoWindow.target.hideText()
            }
        },
        render: function () {
            this.needsRender = true
        },
        frameRender: function () {
            if (this.needsRender) {
                this.checkBounds();
                this.tileGrid.prepare(this.center, this.zoom);
                for (var J = 0; J < this.layers.length; J++) {
                    this.layers[J].render(this.tileGrid)
                }
                this.needsRender = false
            }
            requestAnimFrame(this.frameRender.bind(this))
        },
        setBoundary: function (J) {
            this.boundary = J
        },
        checkBounds: function () {
            if (this.boundary) {
                if (!this.boundary.checkPosition(this.center)) {
                    var K = this.boundary.getClosestPosition(this.center);
                    var P = new D.Core.Position(K.getLat(), K.getLon());
                    this.center = P
                }
            } else {
                var M = (this.leftPosition) ? this.leftPosition.getX(this.zoom) : null;
                var T = (this.rightPosition) ? this.rightPosition.getX(this.zoom) : null;
                var L = (this.btmPosition) ? this.btmPosition.getY(this.zoom) : null;
                var R = (this.topPosition) ? this.topPosition.getY(this.zoom) : null;
                if (this.options.boundaries.top) {
                    var U = R - (this.height / 2);
                    var N = this.center.getY(this.zoom);
                    if (N > U) {
                        N = U
                    }
                    this.center.setXY(this.center.getX(this.zoom), N, this.zoom)
                }
                if (this.options.boundaries.bottom) {
                    var S = L + (this.height / 2);
                    var N = this.center.getY(this.zoom);
                    if (N < S) {
                        N = S
                    }
                    this.center.setXY(this.center.getX(this.zoom), N, this.zoom)
                }
                if (this.options.boundaries.left) {
                    var Q = M + (this.width / 2);
                    var O = this.center.getX(this.zoom);
                    if (O < Q) {
                        O = Q
                    }
                    this.center.setXY(O, this.center.getY(this.zoom), this.zoom)
                }
                if (this.options.boundaries.right) {
                    var W = T - (this.width / 2);
                    var O = this.center.getX(this.zoom);
                    if (O > W) {
                        O = W
                    }
                    this.center.setXY(O, this.center.getY(this.zoom), this.zoom)
                }
                if (this.options.boundaries.top && this.options.boundaries.bottom) {
                    var V = Math.abs(L - R);
                    if (V < this.height) {
                        var N = (L + R) / 2;
                        this.center.setXY(this.center.getX(this.zoom), N, this.zoom)
                    }
                }
                if (this.options.boundaries.left && this.options.boundaries.right) {
                    var J = Math.abs(T - M);
                    if (J < this.width) {
                        var O = (T + M) / 2;
                        this.center.setXY(O, this.center.getY(this.zoom), this.zoom)
                    }
                }
            }
        },
        setStreetView: function () {
            this.streetLayer.show();
            this.satelliteLayer.hide();
            this.hybridLayer.hide();
            this.render();
            this.triggerEvent("viewchange", {
                view: "street"
            })
        },
        setSatelliteView: function () {
            this.streetLayer.hide();
            this.satelliteLayer.show();
            this.hybridLayer.hide();
            this.render();
            this.triggerEvent("viewchange", {
                view: "satellite"
            })
        },
        setHybridView: function () {
            this.streetLayer.hide();
            this.satelliteLayer.show();
            this.hybridLayer.show();
            this.render();
            this.triggerEvent("viewchange", {
                view: "hybrid"
            })
        },
        triggerEvent: function (J, L) {
            var K = {
                center: this.center,
                zoom: this.zoom,
                previousZoom: this.prevZoom,
                targetZoom: this.targetZoom,
                size: {
                    width: this.width,
                    height: this.height
                }
            };
            K = new D.Core.Event(D.Utilities.extendObject(K, L));
            D.Core.EventManager.trigger(J, K, this)
        },
        drawConsole: function () {
            if (!this.console) {
                return
            }
            var J = "";
            for (var K in this.debugInfo) {
                J += K + " : " + this.debugInfo[K] + " <br />"
            }
            this.console.innerHTML = J
        },
        altTap: function (K, L) {
            var J = this.positionFromXY(K.relativeX, K.relativeY);
            this.triggerEvent("rightclick", {
                position: J,
                DOMEvent: K,
                touchEvent: L
            })
        },
        tap: function (K, L) {
            var J = this.positionFromXY(K.relativeX, K.relativeY);
            this.triggerEvent("click", {
                position: J,
                DOMEvent: K,
                touchEvent: L
            })
        },
        doubleTap: function (L, M) {
            if (!this.options.doubleTapZoom) {
                return
            }
            var J = this.positionFromXY(L.relativeX, L.relativeY);
            this.triggerEvent("doubletap", {
                position: J,
                DOMEvent: L,
                touchEvent: M
            });
            if (this.options.zoomFramer) {
                this.options.zoomFramer.framing = true;
                try {
                    this.options.zoomFramer.dom.style.top = L.relativeY + "px";
                    this.options.zoomFramer.dom.style.left = L.relativeX + "px"
                } catch (K) {}
            }
            this.zoomIn(1, J)
        },
        longTouch: function (J, L) {
            var K = this.positionFromXY(J.relativeX, J.relativeY);
            this.triggerEvent("longtouch", {
                position: K,
                DOMEvent: J,
                touchEvent: L
            })
        },
        touchStart: function (J, L) {
            if (!this.options.draggable) {
                return
            }
            this.canvas.style.cursor = 'url("' + D.Core.Configuration.imgPath + '/closedhand.cur"), auto';
            var K = this.positionFromXY(J.relativeX, J.relativeY);
            this.dragging = true;
            this.dragged = false;
            this.panVector.v = 0;
            this.lastMoveX = J.pageX;
            this.lastMoveY = J.pageY;
            if (L.preventDefault) {
                L.preventDefault()
            }
            return false
        },
        touchOut: function (J, K) {
            this.touchEnd(J, K)
        },
        touchEnd: function (J, K) {
            if (!this.dragging) {
                return
            }
            this.dragging = false;
            if (this.dragged) {
                this.triggerEvent("moveend");
                if (this.startZoom == this.zoom || !this.startZoom) {
                    this._ease()
                }
            }
            this.startZoom = null;
            if (K && K.preventDefault) {
                K.preventDefault()
            }
            this.canvas.style.cursor = 'url("' + D.Core.Configuration.imgPath + '/openhand.cur"), auto';
            return false
        },
        touchMove: function (O, Q) {
            if (!this.dragging || !this.options.draggable) {
                return false
            }
            this.debugInfo.tScale = O.scale;
            if (O.scale && O.scale != 1) {
                if (!this.startZoom) {
                    this.startZoom = this.zoom
                }
                var R = this.zoom;
                var J = this.startZoom + ((Math.log(O.scale)) / (Math.log(2)));
                var P = this.positionFromXY(O.centerX, O.centerY);
                this.zoom = J;
                this.center = D.Utilities.getCenterToFixPositionAtNewZoom(P, this.center, R, this.zoom);
                this.triggerEvent("zoomChange", {
                    position: P,
                    DOMEvent: O,
                    touchEvent: Q
                })
            } else {
                var N = O.pageX - this.lastMoveX;
                var L = O.pageY - this.lastMoveY;
                if (D.Window.isIe() && G.msRequestAnimationFrame) {
                    if (N != 0 && L != 0) {
                        this.ang = D.Utilities.getAnglePx({
                            x: 0,
                            y: 0
                        }, {
                            x: N,
                            y: L
                        });
                        if (!this.oldAng) {
                            this.badAngCount = 0;
                            this.oldAng = this.ang
                        }
                        if (this.badAngCount > 4 || ((this.oldAng - 30 < this.ang) && (this.ang < this.oldAng + 30))) {
                            this.panVector.x = N;
                            this.panVector.y = L;
                            this.panVector.v = 1;
                            this.oldAng = this.ang;
                            this.badAngCount = 0
                        } else {
                            this.badAngCount++;
                            return
                        }
                    }
                } else {
                    this.panVector.x = N;
                    this.panVector.y = L;
                    this.panVector.v = 1
                }
                var M = this.center.getX(this.zoom);
                var K = this.center.getY(this.zoom);
                this.center.setXY(M - N, K + L, this.zoom);
                this.lastMoveX = O.pageX;
                this.lastMoveY = O.pageY;
                if (!this.dragged) {
                    this.triggerEvent("movestart", {
                        position: this.center,
                        DOMEvent: O,
                        touchEvent: Q
                    });
                    this.dragged = true
                } else {
                    this.triggerEvent("move", {
                        position: this.center,
                        DOMEvent: O,
                        touchEvent: Q
                    })
                }
            }
            this.debugInfo.moveEvents++;
            this.render();
            if (Q.preventDefault) {
                Q.preventDefault()
            }
            return false
        },
        zoomTo: function (L, K, J) {
            if (L == this.zoom) {
                return
            }
            if (L < this.minZoom) {
                L = this.minZoom
            }
            if (L > this.maxZoom) {
                L = this.maxZoom
            }
            if (Math.abs(L - this.zoom) < 4 && !J) {
                this.targetZoom = L;
                if (!K) {
                    K = this.center
                }
                this._xzoom(this.targetZoom > this.zoom, K)
            } else {
                this.zoom = L;
                this.targetZoom = L;
                this.triggerEvent("zoomEnd", {
                    position: K
                });
                this.render()
            }
        },
        centerOn: function (K, J) {
            if (!J) {
                J = {
                    animated: true,
                    duration: 500
                }
            }
            if (!J.duration) {
                J.duration = 500
            }
            if (!J.onDraw) {
                J.onDraw = null
            }
            if (J.animated) {
                this.targetCenter = new D.Core.Position(K.getLat(), K.getLon());
                this.targetCenterTime = new Date().getTime() + J.duration;
                this._pan(J.onDraw, J.onComplete)
            } else {
                delete this.center;
                this.center = new D.Core.Position(K.getLat(), K.getLon());
                this.center.quantize(this.zoom);
                this.render();
                this.triggerEvent("moveend");
                if (typeof J.onComplete === "function") {
                    setTimeout(function () {
                        J.onComplete()
                    }, 1)
                }
            }
        },
        pan: function (J, K) {
            var M = this.center.getPixelPoint(this.zoom);
            switch (J) {
                case "north":
                    if (!K) {
                        var K = this.height / 2
                    }
                    M.y += K;
                    break;
                case "east":
                    if (!K) {
                        var K = this.width / 2
                    }
                    M.x += K;
                    break;
                case "south":
                    if (!K) {
                        var K = this.height / 2
                    }
                    M.y -= K;
                    break;
                case "west":
                    if (!K) {
                        var K = this.width / 2
                    }
                    M.x -= K;
                    break
            }
            var L = new D.Core.Position(0, 0);
            L.setXY(M.x, M.y, this.zoom);
            this.centerOn(L, {
                animated: true,
                duration: 200
            })
        },
        zoomIn: function (L, K) {
            if (this.zooming) {
                return
            }
            if (this.zoom == this.maxZoom) {
                return
            }
            var J = false;
            if (!L) {
                L = 1;
                J = true
            }
            if (!K) {
                K = this.center
            }
            this.zooming = true;
            this.targetZoom = this.zoom + L;
            if (J) {
                this.targetZoom = Math.round(this.targetZoom)
            }
            if (this.targetZoom > this.maxZoom) {
                this.targetZoom = this.maxZoom
            }
            this._xzoom(true, K)
        },
        zoomOut: function (L, K) {
            if (this.zooming) {
                return
            }
            if (this.zoom == this.minZoom) {
                return
            }
            var J = false;
            if (!L) {
                L = 1;
                J = true
            }
            if (!K) {
                K = this.center
            }
            this.zooming = true;
            this.targetZoom = this.zoom - L;
            if (J) {
                this.targetZoom = Math.round(this.targetZoom)
            }
            if (this.targetZoom < this.minZoom) {
                this.targetZoom = this.minZoom
            }
            this._xzoom(false, K)
        },
        _xzoom: function (P, N) {
            this.prevZoom = this.zoom;
            this.zooming = true;
            this.triggerEvent("zoomStart");
            if (!this.options.digitalZoom) {
                this.zoom = this.targetZoom;
                this.triggerEvent("zoomEnd");
                this.zooming = false;
                this.render();
                return
            }
            var O = 300;
            var M = new Date().getTime();
            var Q = this.zoom;
            var J = this.center;
            var R = this.zoom;
            var L = D.Easing("cubicinout");
            var K = function () {
                var S = new Date().getTime();
                if (S >= M + O) {
                    R = this.zoom;
                    this.zoom = this.targetZoom;
                    this.center = D.Utilities.getCenterToFixPositionAtNewZoom(N, J, Q, this.zoom);
                    this.triggerEvent("zoomEnd");
                    this.render();
                    this.zooming = false
                } else {
                    R = this.zoom;
                    this.zoom = L(S - M, Q, this.targetZoom - Q, O);
                    this.triggerEvent("zoomChange");
                    this.center = D.Utilities.getCenterToFixPositionAtNewZoom(N, this.center, R, this.zoom);
                    this.render();
                    requestAnimFrame(K)
                }
            }.bind(this);
            K()
        },
        _ease: function () {
            if (!this.options.easing) {
                return
            }
            this.triggerEvent("movestart");
            this.easing = true;
            var L = 33;
            var J = 1000 / L;
            var K = 0.9;
            var M = function () {
                if (this.dragging) {
                    return
                }
                this.panVector.v *= K;
                var O = this.panVector.x * this.panVector.v;
                var N = this.panVector.y * this.panVector.v;
                var Q = this.center.getX(this.zoom);
                var P = this.center.getY(this.zoom);
                this.center.setXY(Math.round(Q - O), Math.round(P + N), this.zoom);
                this.triggerEvent("move");
                this.render();
                if (this.panVector.v > 0.05) {
                    requestAnimFrame(M, null, J)
                } else {
                    this.triggerEvent("moveend");
                    this.easing = false
                }
            }.bind(this);
            M()
        },
        _pan: function (P, L) {
            var N = this.center.getX(this.zoom);
            var M = this.center.getY(this.zoom);
            var S = this.targetCenter.getX(this.zoom);
            var R = this.targetCenter.getY(this.zoom);
            var O = this.targetCenterTime - new Date().getTime();
            var Q = Math.floor(O / (1000 / 20));
            if (Q > 0) {
                var K = (S - N) / Q;
                var J = (R - M) / Q;
                var U = N + K;
                var T = M + J;
                this.center.setXY(U, T, this.zoom);
                if (P) {
                    P(this.center)
                }
                this.render();
                requestAnimFrame(function () {
                    this._pan(P, L)
                }.bind(this), null, 1000 / 20)
            } else {
                this.center.setXY(S, R, this.zoom);
                if (L && (typeof L === "function")) {
                    setTimeout(function () {
                        L()
                    }, 1)
                }
                this.render()
            }
        },
        _ready: function () {
            this.frameRender();
            this.ready = true;
            if (typeof this.options.onReady === "function") {
                this.options.onReady(this)
            }
        },
        animating: function () {
            return (this.easing || this.zooming)
        },
        getZoom: function () {
            return this.zoom
        },
        getCenter: function () {
            return this.center
        },
        getRadius: function () {
            var L = new D.Core.Position(0, 0);
            var J = this.center.getX(this.zoom) - (this.width / 2);
            var M = this.center.getY(this.zoom) - (this.height / 2);
            L.setXY(J, M, this.zoom);
            var K = D.Utilities.getPointDistance(this.center, L);
            return new D.Core.Radius(K, "KM")
        },
        positionFromXY: function (J, P) {
            var O = this.center.getX(this.zoom);
            var N = this.center.getY(this.zoom);
            var L = new D.Core.Position(0, 0);
            var M = (J - (this.width / 2));
            var K = (P - (this.height / 2));
            L.setXY(O + M, N - K, this.zoom);
            return L
        },
        getViewHash: function () {},
        getVisibleRect: function () {
            var L = new D.Core.Position(0, 0);
            var J = this.center.getX(this.zoom) - (this.width / 2);
            var O = this.center.getY(this.zoom) - (this.height / 2);
            L.setXY(J, O, this.zoom);
            var K = new D.Core.Position(0, 0);
            var J = this.center.getX(this.zoom) + (this.width / 2);
            var O = this.center.getY(this.zoom) - (this.height / 2);
            K.setXY(J, O, this.zoom);
            var N = new D.Core.Position(0, 0);
            var J = this.center.getX(this.zoom) - (this.width / 2);
            var O = this.center.getY(this.zoom) + (this.height / 2);
            N.setXY(J, O, this.zoom);
            var M = new D.Core.Position(0, 0);
            var J = this.center.getX(this.zoom) + (this.width / 2);
            var O = this.center.getY(this.zoom) + (this.height / 2);
            M.setXY(J, O, this.zoom);
            return [N, M, K, L]
        },
        getBoundingBox: function () {
            return new D.Core.BoundingBox(this.getVisibleRect())
        },
        addControl: function (J, K) {
            J.setOwner(this);
            this.controls.push(J);
            if (D.UI && D.UI.ControlPositioner) {
                D.UI.ControlPositioner.add(J)
            }
            if (!K) {
                this.drawControls()
            }
        },
        removeControl: function (K, L) {
            K.setOwner(this);
            this.controls.push(K);
            for (var J = 0; J < this.controls.length; J++) {}
            if (D.UI && D.UI.ControlPositioner) {
                D.UI.ControlPositioner.add(K)
            }
            if (!L) {
                this.drawControls()
            }
        },
        drawControls: function () {
            var K = [];
            for (var J = 0; J < this.controls.length; J++) {
                this.controls[J].setZ(this.options.controlZ);
                this.controls[J].render(this.containerElement);
                this.controls[J].position(K, this.controls);
                if (D.Utilities.getComputedStyle(this.controls[J].domElement, "display") == "block") {
                    K.push(this.controls[J])
                }
            }
        },
        setTileSize: function (J) {
            D.Core.Constants.TILE_SIZE = J
        },
        suspendResizing: function () {
            this._wasResizeable = this.options.resizeable;
            this.options.resizeable = false
        },
        resumeResizing: function () {
            if (typeof this._wasResizeable === "undefined") {
                return
            }
            this.options.resizeable = this._wasResizeable
        },
        isResizeable: function () {
            return this.options.resizeable
        },
        toJSON: function () {
            var J = {
                center: this.center,
                zoom: this.zoom
            };
            return JSON.stringify(J)
        },
        getViewHash: function (pod) {
            function be(bg, bf) {
                while (bg.length < bf) {
                    bg = "0" + bg
                }
                return bg
            }
            var bc = this.zoom;
            var bd = this.center;
            var ba = be(this._n2s(Math.round((90 + bd.getLat()) * 10000)), 5);
            var bb = be(this._n2s(Math.round((180 + bd.getLon()) * 10000)), 5);
            var a9 = be(this._n2s(bc), 1);
            return a9 + ba + bb
        },

        restoreViewFromHash: function (pod) {

        },

        parseViewHash: function (bd) {
            try {
                var a9 = this._s2n(bd.substr(0, 1));
                var bc = (this._s2n(bd.substr(1, 5)) / 10000) - 90;
                var be = (this._s2n(bd.substr(6, 5)) / 10000) - 180;
                if (isNaN(a9) || isNaN(bc) || isNaN(be)) {
                    return false
                }
                var bb = new deCarta.Core.Position(bc, be)
            } catch (ba) {
                return false
            }
            return { zoom: a9, center: bb }
        },

        _n2s: function (a9) {
            var bb = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-=";
            var ba = "";
            while (a9 > 0) {
                var bc = a9 % 64;
                a9 = a9 >> 6;
                ba = bb.charAt(bc) + ba
            }
            return ba
        },

        _s2n: function (bc) {
            var bb = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-=";
            var ba = 0;
            for (var a9 = 0; a9 < bc.length; a9++) {
                var be = bc.charAt(a9);
                var bd = bb.indexOf(be);
                ba = (ba << 6) + bd
            }
            return ba
        }
    };
    D.Core.Map.prototype = D.Utilities.inherit(D.Core.Map.prototype, D.Core.EventableObject.prototype);
    D.Core.Edge = function (K, J) {
        this.scale = 1.1703344634137277e-8;
        this.pos2point = function (L) {
            return {
                x: D.Utilities.lon2pix(L.getLon(), this.scale),
                y: D.Utilities.lat2pix(L.getLat(), this.scale)
            }
        };
        this.a = this.pos2point(K);
        this.b = this.pos2point(J);
        this.rayIntersect = function (Q) {
            var Q = this.pos2point(Q);
            var O = this.a;
            var M = this.b;
            var P = 9.9999999999911e+29;
            if (O.y > M.y) {
                O = this.b;
                M = this.a
            }
            if (Q.y == O.y || Q.y == M.y) {
                Q.y += 1e-7
            }
            if (Q.y < O.y || Q.y > M.y) {
                return 0
            }
            if (Q.x > Math.max(O.x, M.x)) {
                return 0
            }
            if (Q.x < Math.min(O.x, M.x)) {
                return 1
            }
            if (O.x != M.x) {
                var N = (M.y - O.y) / (M.x - O.x)
            } else {
                var N = P
            }
            if (O.x != Q.x) {
                var L = (Q.y - O.y) / (Q.x - O.x)
            } else {
                var L = P
            }
            return (L >= N) ? 1 : 0
        };
        this.pointDistance = function (X) {
            var X = this.pos2point(X);
            var a = this.a.x;
            var N = this.a.y;
            var Y = this.b.x;
            var L = this.b.y;
            var V = X.x;
            var T = X.y;
            var f = Math.abs((((N - L) * V) + ((Y - a) * T) + ((a * L) - (Y * N))) / Math.sqrt(Math.pow(Y - a, 2) + Math.pow(L - N, 2)));
            var U = (L - N) / (Y - a);
            if (U > 1e+26) {
                U = 1e+26
            }
            if (U == 0) {
                U = 1e-18
            }
            var S = -(1 / U);
            var h = (L - U * Y);
            var g = T - (S * V);
            var P = (g - h) / (U - S);
            var O = (S * P) + g;
            var Q = Math.min(N, L);
            var Z = Math.max(N, L);
            var R = Math.min(a, Y);
            var e = Math.max(a, Y);
            if (Q <= O && O <= Z && R <= P && P <= e) {} else {
                var M = Math.sqrt(Math.pow(V - a, 2) + Math.pow(T - N, 2));
                var W = Math.sqrt(Math.pow(V - Y, 2) + Math.pow(T - L, 2));
                if (M < W) {
                    f = M;
                    O = N;
                    P = a
                } else {
                    f = W;
                    O = L;
                    P = Y
                }
            }
            var k = new D.Core.Position(D.Utilities.pix2lat(O, this.scale), D.Utilities.pix2lon(P, this.scale));
            return {
                distance: f,
                position: k
            }
        }
    };
    D.Core.GeoHash = {
        DICT: "0123456789bcdefghjkmnpqrstuvwxyz",
        encode: function (O, Q, J) {
            if (!J) {
                J = 12
            }
            var L = "";
            var N = {
                bottom: -90,
                top: 90,
                left: -180,
                right: 180
            };
            var M = 0;
            var P = 0;
            while (L.length < J) {
                if (P % 2 == 0) {
                    var K = (N.left + N.right) / 2;
                    if (Q > K) {
                        M |= 16 >> (P % 5);
                        N.left = K
                    } else {
                        N.right = K
                    }
                } else {
                    var K = (N.top + N.bottom) / 2;
                    if (O > K) {
                        M |= 16 >> (P % 5);
                        N.bottom = K
                    } else {
                        N.top = K
                    }
                }
                P++;
                if (P % 5 == 0) {
                    L += this.DICT[M];
                    M = 0
                }
            }
            return L
        },
        decode: function (P) {
            var O = {
                bottom: -90,
                top: 90,
                left: -180,
                right: 180
            };
            var Q = 0;
            for (var M = 0, J = P.length; M < J; M++) {
                var N = this.DICT.indexOf(P[M]);
                for (var L = 0; L < 5; L++) {
                    if (Q % 2 == 0) {
                        var K = (O.left + O.right) / 2;
                        if (N & (16 >> (Q % 5))) {
                            O.left = K
                        } else {
                            O.right = K
                        }
                    } else {
                        var K = (O.top + O.bottom) / 2;
                        if (N & (16 >> (Q % 5))) {
                            O.bottom = K
                        } else {
                            O.top = K
                        }
                    }
                    Q++
                }
            }
            return {
                lat: (O.top + O.bottom) / 2,
                lon: (O.left + O.right) / 2
            }
        }
    };
    D.UI.MapControl = function (J) {
        this.options = {
            position: null,
            marginX: 0,
            marginY: 0,
            layout: function () {
                return {
                    top: 0,
                    left: 0
                }
            }
        };
        this.options = D.Utilities.extendObject(this.options, J);
        this.id = "deCarta-control-" + Math.random().toString().replace(".", "");
        this.domElement = null
    };
    D.UI.MapControl.prototype = {
        render: function () {
            throw ("You are rendering a base MapControl. It does NOTHING!")
        },
        resize: function () {
            return
        },
        show: function () {
            this.domElement.style.display = "block"
        },
        hide: function () {
            this.domElement.style.display = "none"
        },
        remove: function () {
            this.domElement.parent.removeChild(this.domElement)
        },
        position: function (J, L) {
            this.domElement.style.position = "absolute";
            if (this.options.position) {
                return this.quickPosition(J)
            }
            if (this.options.layout) {
                var K = this.options.layout.bind(this)(this.options.map.width, this.options.map.height, J, L)
            }
            this.domElement.style.left = K.left + "px";
            this.domElement.style.top = K.top + "px"
        },
        quickPosition: function (J) {
            function N(W, S, U, V, Q) {
                var O = V;
                for (var R = 0; R < W.length; R++) {
                    var T = W[R];
                    if (S.indexOf(T.options.position) != -1) {
                        var P = T.getPlacement();
                        if (Q) {
                            if (P[U] > O) {
                                O = P[U]
                            }
                        } else {
                            if (P[U] < O) {
                                O = P[U]
                            }
                        }
                    }
                }
                return O
            }
            switch (this.options.position) {
                case "topRight":
                    var K = N(J, ["topRight", "rightTop"], "left", this.options.map.width, false);
                    this.domElement.style.left = K - this.width - this.options.marginX + "px";
                    this.domElement.style.top = this.options.marginY + "px";
                    break;
                case "rightTop":
                    var M = N(J, ["topRight", "rightTop"], "bottom", 0, true);
                    this.domElement.style.top = M + this.options.marginY + "px";
                    this.domElement.style.left = this.options.map.width - this.width - this.options.marginX + "px";
                    break;
                case "bottomLeft":
                    var L = N(J, ["bottomLeft", "leftBottom"], "right", 0, true);
                    this.domElement.style.left = L + this.options.marginX + "px";
                    this.domElement.style.top = this.options.map.height - this.height - this.options.marginY + "px";
                    break;
                case "leftBottom":
                    var M = N(J, ["bottomLeft", "leftBottom"], "top", this.options.map.height, false);
                    this.domElement.style.left = this.options.marginX + "px";
                    this.domElement.style.top = M - this.height - this.options.marginY + "px";
                    break;
                case "bottomRight":
                    var K = N(J, ["bottomRight", "rightBottom"], "left", this.options.map.width, false);
                    this.domElement.style.left = K - this.width - this.options.marginX + "px";
                    this.domElement.style.top = this.options.map.height - this.height - this.options.marginY + "px";
                    break;
                case "rightBottom":
                    var M = N(J, ["bottomRight", "rightBottom"], "top", this.options.map.height, false);
                    this.domElement.style.top = M - this.height - this.options.marginY + "px";
                    this.domElement.style.left = this.options.map.width - this.width - this.options.marginX + "px";
                    break;
                case "topLeft":
                default:
                    var L = N(J, ["topLeft", "leftTop"], "right", 0, true);
                    this.domElement.style.top = this.options.marginY + "px";
                    this.domElement.style.left = L + this.options.marginX + "px";
                    break;
                case "leftTop":
                    var M = N(J, ["topLeft", "leftTop"], "bottom", 0, true);
                    this.domElement.style.top = M + this.options.marginY + "px";
                    this.domElement.style.left = this.options.marginX + "px";
                    break
            }
        },
        setOwner: function (J) {
            this.options.map = J;
            this.options.map.onresize(this.resize.bind(this))
        },
        setZ: function (J) {
            if (this.domElement) {
                this.domElement.style.zIndex = J
            }
            this.z = J
        },
        toJSON: function () {
            var J = {
                marginX: this.options.marginX,
                marginY: this.options.marginY,
                position: this.options.position
            };
            return J
        },
        getPlacement: function () {
            return {
                top: parseFloat(this.domElement.style.top),
                left: parseFloat(this.domElement.style.left),
                width: this.width,
                height: this.height,
                bottom: parseFloat(this.domElement.style.top) + this.height,
                right: parseFloat(this.domElement.style.left) + this.width
            }
        }
    };
    D.Core.MapLayer = function F(J) {
        this.options = {
            canvas: null,
            owner: null,
            name: "Unnamed Layer",
            id: "deCarta-layer-" + Math.random().toString().replace(".", ""),
            visible: true,
            tileStore: new D.Core.StreetTileStore()
        };
        this.options = D.Utilities.extendObject(this.options, J);
        this.ready = false
    };
    D.Core.MapLayer.prototype = {
        _initialize: function () {
            if (!this.options.canvas || !this.options.owner) {
                D.Core.Exception.raise("MapLayer requires a canvas and an owner for instantiation.")
            }
            this.visibleTiles = {};
            this.owner = this.options.owner;
            this.canvas = this.options.canvas;
            this.name = this.options.name;
            this.visible = this.options.visible;
            this.options.tileStore.setOwner(this.owner);
            this.options.tileStore.startPrecaching();
            if (this.owner.options.mode == "canvas" && D.Core.CanvasRenderer) {
                this.renderer = new D.Core.CanvasRenderer(this.canvas)
            } else {
                if (D.Core.Configuration.useHardwareAcceleration && D.Window.hasCSSTransforms()) {
                    this.renderer = new D.Core.CSS3Renderer(this.canvas)
                } else {
                    this.renderer = new D.Core.HTMLRenderer(this.canvas)
                }
            }
            this.resize();
            this.tileStore = this.options.tileStore;
            this.ready = true
        },
        render: function (T) {
            if (!this.visible) {
                return
            }
            var Q = [];
            var M = {};
            var J = T.getGrid();
            var N = J.tiles;
            var L = new Date().getTime();
            for (var R = 0; R < N.length; R++) {
                var O = N[R];
                var S = this.tileStore.getTile(O.E, O.N, O.Z);
                if (!M[S.name]) {
                    var P = {
                        img: S.img,
                        x: O.dX + (S.ofsX * O.size),
                        y: O.dY + (S.ofsY * O.size),
                        size: O.size * S.scale,
                        time: (this.visibleTiles[S.name]) ? this.visibleTiles[S.name] : L,
                        scale: S.scale
                    };
                    if (!(P.x >= this.width || P.y >= this.height || P.x + P.size < 0 || P.y + P.size < 0)) {
                        Q.push(P)
                    }
                    M[S.name] = true
                }
            }
            for (var K in this.visibleTiles) {
                if (!M[K]) {
                    delete this.visibleTiles[K]
                }
            }
            for (var K in M) {
                if (!this.visibleTiles[K]) {
                    this.visibleTiles[K] = new Date().getTime()
                }
            }
            this.tileStore.purgeLoadRequests(J.centerTile, J.zoom, Math.max(J.width, J.height));
            Q.sort(function (V, U) {
                return U.size - V.size
            });
            this.renderer.render(Q)
        },
        setOwner: function (J) {
            this.options.owner = J.owner;
            this.options.canvas = J.canvas;
            this._initialize()
        },
        resize: function (K, J) {
            this.width = K;
            this.height = J;
            this.renderer.resize(K, J)
        },
        show: function () {
            this.visible = true;
            this.renderer.show()
        },
        hide: function () {
            this.visible = false;
            this.renderer.hide()
        },
        toggle: function () {
            if (this.visible) {
                this.hide()
            } else {
                this.show()
            }
        },
        toJSON: function () {
            var J = {
                name: this.options.name,
                visible: this.options.visible,
                tileStore: this.options.tileStore
            };
            return J
        }
    };
    D.Core.MapOverlay = function (J) {
        this.options = {
            canvas: null,
            owner: null,
            name: "Unnamed Layer",
            visible: true,
            zIndex: 0,
            clustering: false,
            clusteringThreshold: 50,
            clusteringOptions: {},
            onClusterClick: function (K) {}
        };
        this.options = D.Utilities.extendObject(this.options, J)
    };
    D.Core.MapOverlay.prototype = {
        _initialize: function () {
            if (!this.options.canvas || !this.options.owner) {
                D.Core.Exception.raise("MapOverlay requires a canvas and an owner for instantiation.")
            }
            this.owner = this.options.owner;
            this.canvas = this.options.canvas;
            this.name = this.options.name;
            this.objects = {};
            this.pins = [];
            this.shapes = [];
            this.images = [];
            this.videos = [];
            this.sounds = [];
            this.clusters = [];
            this.visiblePins = {};
            this.visibleShapes = {};
            this.visible = this.options.visible;
            this.domElement = D.crEl("div");
            this.domElement.id = "deCarta-Mob-Ovl-" + Math.floor(Math.random() * 10000);
            this.domElement.style.position = "absolute";
            this.domElement.style.top = 0;
            this.domElement.style.left = 0;
            this.canvas.appendChild(this.domElement);
            this.width = this.owner.width;
            this.height = this.owner.height;
            this.baseHandle = 0;
            this.lastFullZoom = this.currentZoom = this.owner.zoom;
            D.Core.EventManager.listen("zoomEnd", this._setZoom.bind(this), this.owner);
            D.Core.EventManager.listen("zoomChange", this._setZoom.bind(this), this.owner);
            D.Core.EventManager.listen("zoomStart", this._setZoom.bind(this), this.owner);
            if (!this.attachedEvents) {
                try {
                    this.addListeners(this.domElement)
                } catch (J) {}
                this.attachedEvents = true
            }
        },
        addObject: function (J) {
            var K = J.type;
            J.setZIndex(D.Core.Configuration.baseOvlZ + this.options.zIndex);
            var L = this._genHandle();
            J.handle = L;
            this.objects[L] = J;
            switch (K.toLowerCase()) {
                case "pin":
                    this.indexObject(this.pins, J, L);
                    break;
                case "image":
                case "shape":
                    this.shapes.push(J);
                    break;
                default:
                    throw ("Adding " + K + ' to overlay is not yet supported. Also depending on what "' + K + '" is, it might never be');
                    break
            }
            J.registerOwner(this);
            this.owner.render();
            return L
        },
        indexObject: function (M, J, L) {
            var P = D.Utilities.normalizeZoom(this.currentZoom);
            if (!M[P]) {
                M[P] = {}
            }
            if (this.options.clustering) {
                var O = false;
                for (var K = 0; K < this.clusters.length; K++) {
                    if (this.clusters[K].addPin(J)) {
                        O = true;
                        break
                    }
                }
                if (!O) {
                    var S = D.Utilities.extendObject(this.options.clusteringOptions, {
                        onClick: this.options.onClusterClick,
                        threshold: this.options.clusteringThreshold,
                        zoom: D.Utilities.normalizeZoom(this.currentZoom)
                    });
                    var Q = new D.Core.ClusteredPin(S);
                    Q.addPin(J);
                    this.clusters.push(Q);
                    var N = Q.getPosition().getTileAtZoom(P);
                    var R = D.Utilities.normalizeKey(D.Utilities.getTileKey(N.E, N.N, this.currentZoom));
                    if (!M[P][R]) {
                        M[P][R] = []
                    }
                    var L = this._genHandle();
                    Q.handle = L;
                    this.objects[L] = Q;
                    M[P][R].push(L);
                    Q.registerOwner(this)
                }
            } else {
                var N = J.getPosition().getTileAtZoom(P);
                var R = D.Utilities.normalizeKey(D.Utilities.getTileKey(N.E, N.N, this.currentZoom));
                if (!M[P][R]) {
                    M[P][R] = []
                }
                M[P][R].push(L);
                J.registerOwner(this)
            }
        },
        refreshObjects: function () {
            this._deleteClusters();
            this.pins = [];
            this.shapes = [];
            for (var K in this.objects) {
                var J = this.objects[K];
                if (J.type == "pin") {
                    this.indexObject(this.pins, J, K)
                } else {
                    this.shapes.push(J)
                }
            }
        },
        removeObjectHandle: function (J) {
            if (this.objects[J]) {
                delete this.objects[J]
            }
        },
        removeObject: function (K, J) {
            this.removeObjectHandle(K.handle);
            try {
                if (!J) {
                    this.refreshObjects()
                }
            } catch (L) {}
        },
        show: function () {
            this.visible = true;
            this.domElement.style.display = "block"
        },
        hide: function () {
            this.visible = false;
            this.domElement.style.display = "none"
        },
        render: function (P) {
            if (!this.visible) {
                return
            }
            var O = D.Utilities.removeElementToReinsert(this.domElement);
            var M = P.getGrid();
            var K = M.tiles;
            var J = M.position.getX(this.currentZoom);
            var Q = M.position.getY(this.currentZoom);
            var N = J - M.x;
            var L = Q + M.y;
            this.renderShapes(N, L, K);
            this.renderPins(N, L, K);
            O()
        },
        renderShapes: function (L, J, W) {
            var R = {};
            var Q = new D.Core.BoundingBox(this.owner.getVisibleRect());
            for (var N = 0; N < this.shapes.length; N++) {
                try {
                    var M = this.shapes[N];
                    var U = M.getPosition();
                    var V = U.getX(this.currentZoom) - L;
                    var T = J - U.getY(this.currentZoom);
                    if (Q.intersects(this.shapes[N].getBoundingBox())) {
                        var K = this.shapes[N].render(V, T, this.currentZoom, W);
                        if (K) {
                            if (!K.parentNode) {
                                this.visibleShapes[K.id] = K;
                                R[K.id] = true;
                                this.domElement.appendChild(K);
                                this.shapes[N].render(V, T, this.currentZoom, W)
                            } else {
                                R[K.id] = true
                            }
                        }
                    }
                } catch (P) {
                    console.log("Error rendering shape : ", M, P.message)
                }
            }
            for (var S in this.visibleShapes) {
                if (!R[S]) {
                    var O = this.visibleShapes[S];
                    O.parentNode.removeChild(O);
                    this.visibleShapes[S] = null;
                    delete this.visibleShapes[S]
                }
            }
        },
        renderPins: function (N, M, R) {
            var P = {};
            var K = [];
            for (var O = 0; O < R.length; O++) {
                var Q = D.Utilities.getTileKey(R[O].E, R[O].N, R[O].Z);
                K = K.concat(this.renderTilePins(Q, N, M))
            }
            K.sort(function (T, S) {
                return (parseFloat(T.style.top) - parseFloat(S.style.top))
            });
            for (O = 0; O < K.length; O++) {
                if (!K[O].parentNode || K[O].parentNode.id !== "undefined") {
                    this.visiblePins[K[O].id] = K[O];
                    P[K[O].id] = true;
                    this.domElement.appendChild(K[O])
                } else {
                    P[K[O].id] = true
                }
            }
            for (var L in this.visiblePins) {
                if (!P[L]) {
                    var J = this.visiblePins[L];
                    J.parentNode.removeChild(J);
                    this.visiblePins[L] = null;
                    delete this.visiblePins[L]
                }
            }
        },
        renderTilePins: function (W, N, K) {
            var Q = 0;
            var M = D.Utilities.normalizeZoom(this.currentZoom);
            var J = [];
            var P = 0;
            var R = W;
            W = D.Utilities.normalizeKey(W);
            if (this.pins[M]) {
                if (this.pins[M][W]) {
                    for (P = 0; P < this.pins[M][W].length; P++) {
                        var S = this.pins[M][W][P];
                        var O = this.objects[S];
                        var U = O.getPosition();
                        var V = U.getX(this.currentZoom) - N;
                        var T = K - U.getY(this.currentZoom);
                        var X = O.getSize();
                        if (V > this.owner.width || T > this.owner.height || V + X.width < 0 || T + X.height < 0) {} else {
                            var L = O.render(V, T);
                            J.push(L);
                            Q++
                        }
                    }
                }
            }
            return J
        },
        resize: function (K, J) {
            this.width = K;
            this.height = J;
            this.domElement.style.width = K + "px";
            this.domElement.style.height = J + "px"
        },
        refresh: function () {
            this.owner.render()
        },
        setOwner: function (J) {
            this.options.owner = J.owner;
            this.options.canvas = J.canvas;
            this._initialize()
        },
        clear: function () {
            this._clear()
        },
        _clear: function () {
            this.objects = {};
            this.pins = [];
            this.shapes = [];
            this.images = [];
            this.videos = [];
            this.sounds = [];
            this.clusters = []
        },
        _genHandle: function () {
            return "dcO_" + this.name.replace(" ", "_") + "_" + (this.baseHandle++).toString(16)
        },
        _deleteClusters: function () {
            for (var J = 0; J < this.clusters.length; J++) {
                this.objects[this.clusters[J].handle] = null;
                delete this.objects[this.clusters[J].handle]
            }
            this.clusters = []
        },
        _setZoom: function (K) {
            if (K.object != this.owner) {
                return
            }
            this.currentZoom = K.zoom;
            var L = D.Utilities.normalizeZoom(K.zoom);
            if (this.lastFullZoom != L) {
                this.refreshObjects();
                this.lastFullZoom = L
            }
            for (var J = 0; J < this.shapes.length; J++) {
                this.shapes[J].setZoom(K.zoom)
            }
        },
        toJSON: function () {
            var J = {};
            return J
        },
        touchStart: function (J, K) {
            this.callChildren("touchStart", J, K)
        },
        touchMove: function (J, K) {
            this.callChildren("touchMove", J, K);
            this.callChildren("touchOver", J, K, "touchOut")
        },
        touchEnd: function (J, K) {
            this.callChildren("touchEnd", J, K)
        },
        touchOut: function (J, K) {
            this.callChildren("touchOut", J, K)
        },
        touchOver: function (J, K) {},
        doubleTap: function (J, K) {
            this.callChildren("doubleTap", J, K)
        },
        longTouch: function (J, K) {
            this.callChildren("longTouch", J, K)
        },
        tap: function (J, K) {
            this.callChildren("tap", J, K)
        },
        altTap: function (J, K) {
            this.callChildren("altTap", J, K)
        },
        callChildren: function (J, N, R, O) {
            var K = D.Utilities.domPosition(this.owner.owner.canvas);
            var Q = N.pageX - K.left;
            var P = N.pageY - K.top;
            var L = this.owner.owner.positionFromXY(Q, P);
            for (var M = 0; M < this.shapes.length; M++) {
                if (this.shapes[M].visible) {
                    if (this.shapes[M].checkEvent(N, L)) {
                        this.shapes[M][J](N, R)
                    } else {
                        if (O) {
                            this.shapes[M][O](N, R)
                        }
                    }
                }
            }
        }
    };
    D.Core.MapOverlay.prototype = D.Utilities.inherit(D.Core.MapOverlay.prototype, D.Core.EventableObject.prototype);
    D.Core.BoundingBox = function () {
        var J = Array.prototype.slice.call(arguments);
        if (J.length == 1) {
            var K = J[0]
        } else {
            var K = J.slice(0)
        }
        this.setPoints(K)
    };
    D.Core.BoundingBox.prototype = {
        topLeftPoint: null,
        btmRightPoint: null,
        setPoints: function (K) {
            this.points = [];
            for (var J = 0; J < K.length; J++) {
                if ((typeof K[J]).toLowerCase() === "string") {
                    this.points[J] = new D.Core.Position(K[J])
                } else {
                    this.points[J] = K[J]
                }
            }
            this.findBounds();
            this.points = null
        },
        getCenter: function () {
            var K = (this.topLeftPoint.getX(21) + this.btmRightPoint.getX(21)) / 2;
            var L = (this.topLeftPoint.getY(21) + this.btmRightPoint.getY(21)) / 2;
            var J = new D.Core.Position();
            J.setXY(K, L, 21);
            return J
        },
        contains: function (P) {
            var K = this.topLeftPoint.getX(21);
            var M = this.btmRightPoint.getX(21);
            var L = this.topLeftPoint.getY(21);
            var O = this.btmRightPoint.getY(21);
            var J = P.getX(21);
            var N = P.getY(21);
            return (J >= K && J <= M && N >= O && N <= L)
        },
        intersects: function (N) {
            var M = this.topLeftPoint.getX(21);
            var Q = this.btmRightPoint.getX(21);
            var J = this.topLeftPoint.getY(21);
            var O = this.btmRightPoint.getY(21);
            var R = N.topLeftPoint.getX(21);
            var L = N.btmRightPoint.getX(21);
            var K = N.topLeftPoint.getY(21);
            var P = N.btmRightPoint.getY(21);
            return !(R > Q || L < M || P > J || K < O)
        },
        getIdealCenterAndZoom: function (L) {
            var S = Array.prototype.slice.call(arguments);
            var M = 0;
            var Y = 0;
            if (S.length == 2) {
                M = parseFloat(S[0]);
                Y = parseFloat(S[1])
            } else {
                if (S.length == 1) {
                    if (typeof S[0] == "object") {
                        M = S[0].width;
                        Y = S[0].height
                    } else {
                        if (typeof S[0] == "string") {
                            var Q = D.geId(S[0]);
                            M = Q.offsetWidth;
                            Y = Q.offsetHeight
                        } else {
                            D.Core.Exception.raise("I have no idea what you might be trying to do. BoundingBox.getIdealCenterAndZoom can accept: aString, and Object {width: N, height: N}, a Map, or a DOM id. You are passing something weird.")
                        }
                    }
                } else {
                    D.Core.Exception.raise("There are too many arguments in this call to the BoundingBox getIdealGenterAndZoom.")
                }
            }
            var R = {
                zoom: null,
                center: null
            };
            for (var T = 20; T > 0; T--) {
                var N = this.topLeftPoint.getX(T);
                var X = this.topLeftPoint.getY(T);
                var K = this.btmRightPoint.getX(T);
                var V = this.btmRightPoint.getY(T);
                var P = Math.abs(K - N);
                var O = Math.abs(V - X);
                if (P <= M && O <= Y) {
                    R.zoom = T;
                    break
                }
            }
            var W = (this.topLeftPoint.getX(R.zoom) + this.btmRightPoint.getX(R.zoom)) / 2;
            var U = (this.topLeftPoint.getY(R.zoom) + this.btmRightPoint.getY(R.zoom)) / 2;
            var J = new D.Core.Position();
            J.setXY(W, U, R.zoom);
            R.center = J;
            return R
        },
        getSize: function (L) {
            var N = this.topLeftPoint.getY(L);
            var M = this.topLeftPoint.getX(L);
            var J = this.btmRightPoint.getY(L);
            var K = this.btmRightPoint.getX(L);
            return {
                width: K - M,
                height: N - J
            }
        },
        findBounds: function () {
            this.topLeftPoint = null;
            this.btmRightPoint = null;
            var J = null;
            var Q = null;
            var P = null;
            var N = null;
            for (var M = 0; M < this.points.length; M++) {
                var O = this.points[M];
                var L = O.getX(18);
                var K = O.getY(18);
                if (L < J || !J) {
                    J = L
                }
                if (K < Q || !Q) {
                    Q = K
                }
                if (L > P || !P) {
                    P = L
                }
                if (K > N || !N) {
                    N = K
                }
                delete O
            }
            this.topLeftPoint = new D.Core.Position(0, 0);
            this.btmRightPoint = new D.Core.Position(0, 0);
            this.topLeftPoint.setXY(J, N, 18);
            this.btmRightPoint.setXY(P, Q, 18)
        }
    };
    D.Core.MapBoundary = function () {
        this.edges = []
    };
    D.Core.MapBoundary.prototype = {
        fromPoly: function (J) {
            this.setPositions(J.options.vertices)
        },
        setPositions: function (J) {
            this.edges = [];
            if (J.length < 3) {
                throw ("I believe you need at least 3 vertices to define a polygon, and a MapBoundary happens to be a polygon.")
            }
            for (var K = 0; K < J.length; K++) {
                if (J[K + 1]) {
                    this.edges.push(new D.Core.Edge(J[K], J[K + 1]))
                } else {
                    this.edges.push(new D.Core.Edge(J[K], J[0]))
                }
            }
        },
        checkPosition: function (J) {
            var L = 0;
            for (var K = 0; K < this.edges.length; K++) {
                var M = this.edges[K];
                L += M.rayIntersect(J)
            }
            return (L % 2 == 1)
        },
        getClosestPosition: function (J) {
            var K = parseFloat("Infinity");
            var O = null;
            for (var M = 0; M < this.edges.length; M++) {
                var N = this.edges[M];
                var L = this.edges[M].pointDistance(J);
                if (L.distance < K) {
                    K = L.distance;
                    O = L.position
                }
            }
            return O
        }
    };
    D.Core.TileGrid = function () {
        this.tiles = [];
        this.zoom = 0;
        this.width = this.height = 0
    };
    D.Core.TileGrid.prototype = {
        prepare: function (J, Z) {
            this.zoom = Z;
            var K = this.width;
            var X = this.height;
            var S = Math.round(J.getX(Z));
            var P = Math.round(J.getY(Z));
            var Y = D.Utilities.tileSizeForZoom(Z);
            var M = Math.pow(D.Utilities.normalizeZoom(Z), 2);
            var T = Math.floor(S / Y);
            var L = Math.floor(P / Y);
            var R = S % Y;
            var O = P % Y;
            if (R == 0 && T < 0) {
                T -= 1
            }
            this.centerTile = {
                E: T,
                N: L,
                Z: Z,
                lat: J.getLat(),
                lon: J.getLon()
            };
            this.xTiles = Math.floor((K + (2 * Y)) / Y);
            this.yTiles = Math.floor((X + (2 * Y)) / Y);
            var Q = Math.ceil(((K / 2) - R - Y) / Y);
            var N = Math.ceil(((X / 2) + O - Y) / Y);
            this.gridX = ((K / 2) - R - Y) - (Y * Q);
            this.gridY = ((X / 2) + O - Y) - (Y * N);
            this.tiles = [];
            for (var W = 0; W < this.xTiles; W++) {
                for (var V = 0; V < this.yTiles; V++) {
                    var U = {};
                    U.size = Y;
                    U.E = (T - (Q - W));
                    U.N = (L + (N - V));
                    U.Z = Z;
                    if (L < 0) {
                        U.N += 1
                    }
                    if (T >= 0) {
                        U.E -= 1
                    }
                    U.dX = this.gridX + (Y * W);
                    U.dY = this.gridY + (Y * V);
                    if (V == 0 && W == 0) {
                        this.gridPosition = D.Utilities.getTilePosition(U.E, U.N, U.Z)
                    }
                    this.tiles.push(U)
                }
            }
            this.tiles.sort(function (d, c) {
                var f = Math.sqrt(Math.pow(d.E - T, 2) + Math.pow(d.N - L, 2));
                var e = Math.sqrt(Math.pow(c.E - T, 2) + Math.pow(c.N - L, 2));
                return f - e
            });
            return
        },
        getGrid: function () {
            return {
                tiles: this.tiles,
                x: this.gridX,
                y: this.gridY,
                position: this.gridPosition,
                centerTile: this.centerTile,
                zoom: this.zoom,
                width: this.xTiles,
                height: this.yTiles
            }
        },
        resize: function (K, J) {
            this.width = K;
            this.height = J
        }
    };
    D.Core.EventManager = {
        events: {
            zoomstart: [],
            zoomchange: [],
            zoomend: [],
            hoveron: [],
            hoveroff: [],
            movestart: [],
            move: [],
            moveend: [],
            click: [],
            hoveron: [],
            hoveroff: [],
            doubleclick: [],
            rightclick: [],
            resize: [],
            showpintext: [],
            hidepintext: [],
            tileload: [],
            longtouch: [],
            viewchange: []
        },
        eventNames: {
            zoomstart: "zoomstart",
            zoomchange: "zoomchange",
            zoomend: "zoomend",
            movestart: "movestart",
            move: "move",
            moveend: "moveend",
            click: "click",
            mouseover: "hoveron",
            mouseout: "hoveroff",
            hoveron: "hoveron",
            hoveroff: "hoveroff",
            tap: "click",
            press: "click",
            doubleclick: "doubleclick",
            doubletap: "doubleclick",
            doublepress: "doubleclick",
            rightclick: "rightclick",
            alttap: "rightclick",
            rightpress: "rightclick",
            resize: "resize",
            showpintext: "showpintext",
            hidepintext: "hidepintext",
            tileload: "tileload",
            longtouch: "longtouch",
            longclick: "longtouch",
            longpress: "longtouch",
            viewchange: "viewchange"
        },
        listen: function (K, N, L) {
            K = this.eventNames[K.toLowerCase()];
            K = K.toLowerCase();
            var L = L;
            var M = function (P, O) {
                if (L && O) {
                    if (L != O) {
                        return
                    }
                }
                if (!L) {
                    N(P, O)
                } else {
                    N.call(L, P, O)
                }
            };
            if (this.events[K]) {
                for (var J = 0; J < this.events[K].length; J++) {
                    if (this.events[K][J] == null) {
                        this.events[K][J] = M;
                        return J
                    }
                }
                this.events[K].push(M);
                return this.events[K].length - 1
            } else {
                throw ("Event " + K + " is not supported")
            }
        },
        trigger: function (K, M, L) {
            K = this.eventNames[K.toLowerCase()];
            M.eventType = K;
            M.object = L;
            if (!this.events[K]) {
                throw ('You are trying to trigger the event "' + K + '", but it does not exist.')
            }
            for (var J = 0; J < this.events[K].length; J++) {
                if (this.events[K][J]) {
                    this.events[K][J](M, L)
                }
            }
        },
        stopListeningByIdx: function (K, J) {
            K = this.eventNames[K.toLowerCase()];
            this.events[K][J] = null
        },
        stopListening: function (J, K) {
            return (this.stopListeningByIdx(J, K))
        }
    };
    D.Core.Configuration = {
        clientName: null,
        clientPassword: null,
        url: "http://ws.decarta.com/openls/JSON",
        language: "EN",
        country: "US",
        projection: "EPSG:3857",
        imgPath: "img/",
        metric: false,
        vocalExceptions: false,
        baseOvlZ: 100,
        streetTileHosts: ["http://wsdds2-qa.sanjose.telcontar.com", "http://wsdds2-qa.sanjose.telcontar.com", "http://wsdds2-qa.sanjose.telcontar.com"],
        defaultConfig: "global-decarta",
        showTraffic: false,
        defaultHighResConfig: "global-decarta",
        defaultTransparentConfig: "global-decarta-transparent",
        resourceBase: "resources/",
        baseImagePack: "StdResImages.js",
        baseHiResImagePack: "HiResImages.js",
        additionalImagePacks: {
            hiRes: [],
            loRes: []
        },
        resourceTimeout: 20000,
        requestTimeout: 15000,
        digitalGlobeKey: null,
        digitalGlobeConnectID: null,
        mapitImageryKey: null,
        mapitImageryFromZoomLevel: null,
        mapitImageryToZoomLevel: null,
        DGUrlVersion: 2,
        digitalGlobeHosts: ["http://www1.globexplorer.com", "http://www2.globexplorer.com", "http://www3.globexplorer.com"],
        useHardwareAcceleration: true,
        buildDate: "2013/01/10 16:18",
        version: "3.0.6.50",
        imagePort: 0,
        useCache: true,
        dataSet: "navteq-world",
        apiVersion: null,
        urlVersion: "auto",
        consolelogXML: false,
        usePrecaching: false
    };
    D.Core.ZoomFramer = function (J) {
        this.map = null;
        this.dom;
        this.framing = false;
        this.options = {
            stepsPerScroll: 3,
            min: 20,
            max: 120,
            borderColor: "#444",
            borderRadius: "100em",
            fillColor: "#999",
            opacity: 20
        };
        this.options = D.Utilities.extendObject(this.options, J)
    };
    D.Core.ZoomFramer.prototype = {
        setOwner: function (J) {
            this.map = J;
            this.init()
        },
        init: function () {
            this.dom = D.crEl("div");
            this.map.containerElement.appendChild(this.dom);
            this.dom.style.zIndex = 1000;
            this.dom.style.backgroundColor = this.options.fillColor;
            this.dom.style.border = "1px solid " + this.options.borderColor;
            this.dom.style.borderRadius = this.options.borderRadius;
            this.dom.style.display = "block";
            this.dom.style.position = "absolute";
            D.Utilities.setOpacity(this.dom, this.options.opacity);
            if (!this.map.options.avoidEvents) {
                if (this.map.containerElement.addEventListener) {
                    this.map.containerElement.addEventListener("DOMMouseScroll", this.scrollWheel.bind(this), false)
                }
                this.map.containerElement.onmousewheel = this.scrollWheel.bind(this)
            }
            this.map.onzoomstart(function (M) {
                if (!this.framing) {
                    return
                }
                this.steps = 0;
                var L = (M.zoom - M.targetZoom < 0) ? this.options.min : this.options.max;
                this.dom.style.height = L + "px";
                this.dom.style.width = L + "px";
                var K = parseFloat(this.dom.style.top);
                var J = parseFloat(this.dom.style.left);
                this.dom.style.top = K - (L / 2) + "px";
                this.dom.style.left = J - (L / 2) + "px";
                this.dom.style.display = "block"
            }.bind(this));
            this.map.onzoomchange(function (J) {
                if (!this.framing) {
                    return
                }
                this.steps++;
                var O = this.dom;
                var K = (J.zoom - J.targetZoom < 0) ? 1.2 : 0.6;
                var N = parseFloat(O.style.height);
                var Q = parseFloat(O.style.width);
                var R = parseFloat(O.style.top) - 1;
                var L = parseFloat(O.style.left) - 1;
                var P = N * K;
                var M = Q * K;
                O.style.height = P + "px";
                O.style.width = M + "px";
                O.style.top = R + ((N - P) / 2) + "px";
                O.style.left = L + ((Q - M) / 2) + "px"
            }.bind(this));
            this.map.onzoomend(function () {
                this.framing = false;
                this.dom.style.display = "none"
            }.bind(this))
        },
        scrollWheel: function (M) {
            this.framing = true;
            M = M ? M : G.event;
            try {
                if (M.stopPropagation) {
                    M.stopPropagation()
                }
                if (M.preventDefault) {
                    M.preventDefault()
                }
                M.cancelBubble = true;
                M.returnValue = false
            } catch (M) {}
            var K = M.detail ? M.detail * -1 : M.wheelDelta / 40;
            var J = M.clientX - D.Utilities.domPosition(this.map.containerElement).left;
            var N = M.clientY - D.Utilities.domPosition(this.map.containerElement).top;
            this.dom.style.top = N + "px";
            this.dom.style.left = J + "px";
            this.dom.style.height = "0px";
            this.dom.style.width = "0px";
            var L = this.map.positionFromXY(J, N);
            if (K > 0) {
                this.map.zoomIn(this.options.stepsPerScroll, L, true)
            } else {
                this.map.zoomOut(this.options.stepsPerScroll, L, true)
            }
        }
    };
    D.Core.InfoWindow = function (J) {
        this.map = J;
        this.visible = false;
        this.domElement = D.crEl("div");
        this.baseCssName = this.domElement.className = "deCarta-InfoWindow";
        this.background = D.crEl("div");
        this.background.className = "deCarta-InfoWindow-Background";
        this.contentWrapper = D.crEl("div");
        this.contentWrapper.className = "deCarta-InfoWindow-Content-External";
        this.contentElement = D.crEl("div");
        this.contentElement.className = "deCarta-InfoWindow-Content";
        this.contentWrapper.appendChild(this.contentElement);
        this.domElement.appendChild(this.background);
        this.domElement.appendChild(this.contentWrapper);
        D.Touch.attachListener("touchstart", this.domElement, this.devNull.bind(this), true);
        D.Touch.attachListener("touchend", this.domElement, this.devNull.bind(this), true);
        D.Touch.attachListener("touchstart", this.domElement, this.devNull.bind(this), true);
        if (this.domElement.addEventListener) {
            this.domElement.addEventListener("DOMMouseScroll", this.scrollWheel.bind(this), false)
        }
        this.domElement.onmousewheel = this.scrollWheel.bind(this)
    };
    D.Core.InfoWindow.prototype = {
        onClose: null,
        show: function (J) {
            if (this.visible) {
                this.hide()
            }
            if (typeof J.content == "string") {
                this.contentElement.innerHTML = J.content
            } else {
                this.contentElement.innerHTML = "";
                this.contentElement.appendChild(J.content)
            }
            this.target = J.target;
            this.onClose = J.onClose;
            this.cssClass = J.cssClass;
            this.autoReorient = (J.autoReorient || true);
            setTimeout(function () {
                this.position()
            }.bind(this), 0);
            this.visible = true;
            return this.domElement
        },
        updateText: function (J) {
            if (typeof J == "string") {
                this.contentElement.innerHTML = J
            } else {
                this.contentElement.innerHTML = "";
                this.contentElement.appendChild(J)
            }
            setTimeout(function () {
                this.position()
            }.bind(this), 0)
        },
        hide: function () {
            this.domElement.style.display = "none";
            this.visible = false;
            if (this.onClose) {
                this.onClose()
            }
        },
        getElement: function () {
            return this.domElement
        },
        position: function () {
            this.domElement.style.display = "block";
            var J = this.target.getBounds();
            var N = this.target.getAnchorPositions();
            var L = this.map.width;
            var M = this.map.height;
            var K = this.domElement.offsetWidth;
            var S = this.domElement.offsetHeight;
            var Q = "bottom";
            var R = "center";
            if (this.autoReorient) {
                if (S > J.top) {
                    Q = "top"
                }
                if (K / 2 > J.left) {
                    R = "right"
                } else {
                    if (K / 2 > (L - J.right)) {
                        R = "left"
                    }
                }
            }
            var O = (Q == "bottom") ? N.top - S : N.bottom;
            this.domElement.style.top = O + "px";
            var P = (R == "center") ? (N.right + N.left - K) / 2 : (R == "left") ? N.right - (K) : N.left;
            this.domElement.style.left = P + "px";
            this.domElement.className = "deCarta-InfoWindow " + Q + " " + R + " " + this.cssClass;
            this.domElement.style.display = "none";
            this.domElement.offsetHeight;
            this.domElement.style.display = "block"
        },
        scrollWheel: function (J) {
            if (J.stopPropagation) {
                J.stopPropagation()
            } else {
                J.cancelBubble = true
            }
        },
        devNull: function (J, K) {
            D.Touch.stopEvent(J)
        }
    };
    D.Core.TilePrecacher = function (K, J) {
        this.maxRequests = 4;
        this.map = K;
        this.tileStore = J;
        this.grid = new D.Core.TileGrid();
        this.init()
    };
    D.Core.TilePrecacher.prototype = {
        init: function () {
            this.precachePoll()
        },
        precachePoll: function () {
            var N = false;
            for (var O in this.tileStore.loadRequests) {
                N = true;
                break
            }
            if (N) {} else {
                var Q = 0;
                this.grid.resize(this.map.width, this.map.height);
                for (var P = 1; P < 21 && Q < this.maxRequests; P += 5) {
                    this.grid.prepare(this.map.center, P);
                    var L = this.grid.getGrid();
                    for (var K = 0; K < L.tiles.length; K++) {
                        var M = L.tiles[K];
                        var J = D.Utilities.getTileKey(M.E, M.N, M.Z);
                        if (!this.tileStore.availableTiles[J]) {
                            this.tileStore.getTile(M.E, M.N, M.Z);
                            Q++
                        }
                    }
                }
            }
            setTimeout(this.precachePoll.bind(this), 500)
        }
    };
    D.Core.TileStore = function (J) {
        this.opts = {
            baseConfig: "global-decarta",
            hiResConfig: null,
            precache: false
        };
        this.tileStoreId = "dCTileStore-" + (Math.random() + "").replace(".", "");
        this.opts = D.Utilities.extendObject(this.opts, J);
        this.tileTimeout = 10000;
        this.tileCacheSize = D.Window.isMobile() ? 50 : 200;
        this.availableTiles = {};
        this.tileCount = 0;
        this.keyStack = [];
        this.loadingTiles = {};
        this.loadRequests = {};
        this.blankTiles = {};
        this.tileTimeouts = [];
        this.blankTile = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
        this.blankTileImg = new Image();
        this.blankTileImg.src = this.blankTile;
        D.Core.EventManager.listen("zoomEnd", this.zoomEnd.bind(this))
    };
    D.Core.TileStore.prototype = {
        getKey: function (J, L, K) {
            return D.Utilities.getTileKey(J, L, K) + "-" + D.Core.Configuration.defaultConfig + "-TDATA=" + D.Core.Configuration.showTraffic
        },
        getTile: function (J, N, M) {
            M = Math.floor(M);
            var K = this.getKey(J, N, M);
            if (this.availableTiles[K] && this.availableTiles[K].img && this.availableTiles[K].img.src) {
                return this.availableTiles[K]
            }
            if (this.loadingTiles[K]) {
                return this.getNextBestTile(J, N, M)
            }
            this.loadingTiles[K] = true;
            var L = new Image();
            L.key = K;
            L.tileStoreId = this.tileStoreId;
            L.timeout = setTimeout(this.purgeRequest.bind(this, K), this.tileTimeout);
            L.onload = function (R) {
                if (this.tileStoreId != R.tileStoreId) {
                    return
                }
                clearTimeout(R.timeout);
                var P = new Date().getTime();
                R.loadTime = P;
                var Q = {};
                Q.name = K;
                Q.img = R;
                Q.scale = 1;
                Q.ofsX = 0;
                Q.ofsY = 0;
                this.availableTiles[K] = Q;
                this.keyStack.push(K);
                this.tileCount++;
                delete this.loadingTiles[K];
                delete this.loadRequests[K];
                this.removeBlankTile(K);
                R.onload = null;
                if (this.tileCount > this.tileCacheSize) {
                    var O = this.keyStack.shift(K);
                    delete this.availableTiles[O];
                    this.tileCount--
                }
                D.Core.EventManager.trigger("tileLoad", R)
            }.bind(this, L);
            L.onerror = function (O) {
                this.purgeRequest(this.key)
            }.bind(this);
            this.loadRequests[K] = L;
            L.src = this.getTileUrl(J, N, M);
            return this.getNextBestTile(J, N, M)
        },
        purgeLoadRequests: function (M, L, J) {
            L = D.Utilities.normalizeZoom(L);
            for (var K in this.loadRequests) {
                var N = D.Utilities.splitTileKey(K);
                if (N.z != L) {
                    continue
                }
                var O = Math.floor(Math.sqrt(Math.pow(M.E - N.x, 2) + Math.pow(M.N - N.y, 2)));
                if (O > (J / 2) + 1) {
                    this.purgeRequest(K)
                }
            }
        },
        purgeRequest: function (J) {
            if (this.loadRequests[J]) {
                this.loadRequests[J].onload = null;
                this.loadRequests[J].src = null;
                delete this.loadRequests[J]
            }
            if (this.loadingTiles[J]) {
                delete this.loadingTiles[J]
            }
        },
        zoomEnd: function (K) {
            this.currentZoom = K.zoom;
            for (var J in this.loadRequests) {
                var L = D.Utilities.splitTileKey(J);
                if (L.z != this.currentZoom) {
                    if (!this.availableTiles[J]) {
                        this.purgeRequest(J)
                    }
                }
            }
        },
        getTileUrl: function () {
            throw ("This is a base class. Extend it and override this method. ")
        },
        getNextBestTile: function (V, U, T) {
            T = Math.round(T);
            for (var P = 1; P < 6; P++) {
                var O = T - P;
                var S = V / Math.pow(2, P);
                var R = U / Math.pow(2, P);
                if (S < 0) {
                    S = Math.floor(S)
                } else {
                    S = Math.floor(S)
                }
                if (R < 0) {
                    R = Math.floor(R)
                } else {
                    R = Math.floor(R)
                }
                var Q = S * Math.pow(2, P);
                var N = R * Math.pow(2, P);
                var K = Q - V;
                var J = N - U;
                var W = this.getKey(S, R, O);
                if (this.availableTiles[W]) {
                    var M = Math.pow(2, P);
                    J = Math.abs(J) - (M - 1);
                    var L = {};
                    L.name = W;
                    L.img = this.availableTiles[W].img;
                    L.scale = Math.pow(2, P);
                    L.ofsX = K;
                    L.ofsY = J;
                    return L
                }
            }
            var W = this.getKey(V, U, T);
            L = {};
            L.name = "empty_" + W;
            L.img = this.getBlankTile(W);
            L.img.empty = true;
            L.scale = 1;
            L.ofsX = 0;
            L.ofsY = 0;
            return L
        },
        getBlankTile: function (J) {
            if (this.blankTiles[J]) {
                return this.blankTiles[J]
            }
            this.blankTiles[J] = this.blankTileImg.cloneNode(true);
            this.blankTiles[J].id = "empty_" + J;
            this.blankTiles[J].key = "empty_" + J;
            return this.blankTiles[J]
        },
        removeBlankTile: function (J) {
            if (this.blankTiles[J]) {
                delete this.blankTiles[J]
            }
        },
        setOwner: function (J) {
            this.owner = J
        },
        startPrecaching: function () {
            if (!D.Core.Configuration.usePrecaching) {
                return
            }
            if (!this.opts.precache) {
                return
            }
            if (!this.precacher) {
                this.precacher = new D.Core.TilePrecacher(this.owner, this)
            }
        },
        toJSON: function () {
            var J = {
                opts: this.opts
            };
            return J
        }
    };
    D.Core.StreetTileStore = function (J) {
        D.Core.TileStore.call(this, J);
        this._ll_LUT = D.Core.Constants._ll_LUT;
        this.hostIdx = 0
    };
    D.Core.StreetTileStore.prototype = {
        getTileUrl: function (Q, P, O) {
            var R = D.Window.getDpr();
            var L = (R > 1) ? D.Core.Configuration.defaultHighResConfig : D.Core.Configuration.defaultConfig;
            var M = D.Core.Configuration.imagePort ? ":" + D.Core.Configuration.imagePort : "";
            var J = D.Core.Configuration.imageCache ? "image-cache" : "image";
            var N = D.Core.Configuration.dataSet ? D.Core.Configuration.dataSet : "navteq-world";
            if (D.Core.Configuration.urlVersion == 2) {
                var K = D.Core.Configuration.streetTileHosts[this.hostIdx] + M + "/openls/" + J + "/TILE/" + Q + "/" + P + "/" + O + "?CLIENTNAME=" + D.Core.Configuration.clientName + "&SESSIONID=" + D.Core.JSRequest.sessionId + "&CONFIG=" + L + "&P=" + D.Core.Configuration.projection;
                return K
            }
            var K = D.Core.Configuration.streetTileHosts[this.hostIdx] + M + "/openls/" + J + "/TILE?LLMIN=0.0,0.0&LLMAX=" + this._ll_LUT[D.Core.Configuration.projection][Math.round(O)] + "&CACHEABLE=true&DS=" + N + "&WIDTH=" + (256) + "&HEIGHT=" + (256) + (D.Core.Configuration.showTraffic ? "&TDATA=true" : "&TDATA=false") + "&CLIENTNAME=" + D.Core.Configuration.clientName + "&SESSIONID=" + D.Core.JSRequest.sessionId + "&FORMAT=PNG&CONFIG=" + L + "&N=" + P + "&E=" + Q + "&P=" + D.Core.Configuration.projection;
            this.hostIdx = (this.hostIdx + 1) % D.Core.Configuration.streetTileHosts.length;
            return K
        }
    };
    D.Core.StreetTileStore.prototype = D.Utilities.inherit(D.Core.StreetTileStore.prototype, D.Core.TileStore.prototype);
    D.Core.SatelliteTileStore = function (J) {
        D.Core.TileStore.call(this, J);
        this.hosts = D.Core.Configuration.digitalGlobeHosts;
        this.hostIdx = 0
    };
    D.Core.SatelliteTileStore.prototype = {
        getKey: function (J, L, K) {
            return D.Utilities.getTileKey(J, L, K) + "-DG-" + D.Core.Configuration.DGUrlVersion
        },
        getTileUrl: function (Q, O, M) {
            var R = 1;
            var P = D.Utilities.getTilePosition(Q, O, M);
            var N = P.getLat() % 180;
            var K = P.getLon() % 360;
            if (K < -180) {
                K = 360 + K
            }
            if (K > 180) {
                K = K - 360
            }
            if (D.Core.Configuration.DGUrlVersion == 2 && (D.Core.Configuration.projection == "EPSG:3857")) {
                if (D.Core.Configuration.mapitImageryKey && M >= D.Core.Configuration.mapitImageryFromZoomLevel && M <= D.Core.Configuration.mapitImageryToZoomLevel) {
                    var params = 'key=' + D.Core.Configuration.mapitImageryKey +
                                   '&LAYERS=sm.imagery' +
                                   '&STYLES=' +
                                   '&BGCOLOR=0xFFFFFF' +
                                   '&FORMAT=image/jpg' +
                                   '&SERVICE=WMS' +
                                   '&TRANSPARENT=TRUE' +
                                   '&VERSION=1.1.1' +
                                   '&REQUEST=GetMap' +
                                   '&SRS=EPSG:3857' +
                                   '&WIDTH=' + (256 /* * dpr*/) +
                                   '&HEIGHT=' + (256 /* * dpr*/);
                    var l = "http://www.streetmaps.co.za/WMS/?" + params;
                    var url = l + '&BBOX=' + D.Utilities.calcMercator_BBOX(Q, O, M);
                    l = url;
                    return l;
                }
                else if (D.Core.Configuration.digitalGlobeConnectID){
                    var L = Math.pow(2, M);
                    O++;
                    Q = (Q + (L / 2)) % L;
                    O = (-O + (L / 2)) % L;
                    if (Q < 0) {
                        Q = L + Q
                    }
                    if (O < 0) {
                        O = L + O
                    }
                    var J = "https://services.digitalglobe.com/earthservice/wmtsaccess?CONNECTID=" + D.Core.Configuration.digitalGlobeConnectID + "&Service=WMTS&REQUEST=GetTile&Version=1.0.0&Layer=DigitalGlobe:ImageryTileService&TileMatrixSet=" + D.Core.Configuration.projection + "&TileMatrix=" + D.Core.Configuration.projection + ":" + M + "&Format=image/jpeg&TileRow=" + O + "&TileCol=" + Q;
                    return J
                }
            }
            var J = this.hosts[this.hostIdx] + "/tiles/decarta?key=" + D.Core.Configuration.digitalGlobeKey + "&LL=" + N + "," + K + "&ZOOM=" + M + "&CACHEABLE=true&DS=navteq&WIDTH=" + 256 + "&HEIGHT=" + 256 + "&FORMAT=PNG&CLIENTNAME=" + D.Core.Configuration.clientName + "&SESSIONID=9809958&CONFIG=transparent-tile&N=0&E=0";
            return J
        }
    };
    D.Core.SatelliteTileStore.prototype = D.Utilities.inherit(D.Core.SatelliteTileStore.prototype, D.Core.TileStore.prototype);
    D.Core.TransparentTileStore = function (J) {
        D.Core.TileStore.call(this, J);
        this._ll_LUT = D.Core.Constants._ll_LUT;
        this.hostIdx = 0
    };
    D.Core.TransparentTileStore.prototype = {
        getKey: function (J, L, K) {
            return D.Utilities.getTileKey(J, L, K) + "-" + D.Core.Configuration.defaultTransparentConfig
        },
        getTileUrl: function (Q, P, O) {
            var R = D.Window.getDpr();
            var L = D.Core.Configuration.defaultTransparentConfig;
            var M = D.Core.Configuration.imagePort ? ":" + D.Core.Configuration.imagePort : "";
            var J = D.Core.Configuration.imageCache ? "image-cache" : "image";
            var N = D.Core.Configuration.dataSet ? D.Core.Configuration.dataSet : "navteq-world";
            if (D.Core.Configuration.urlVersion == 2) {
                var K = D.Core.Configuration.streetTileHosts[this.hostIdx] + M + "/openls/" + J + "/TILE/" + Q + "/" + P + "/" + O + "?CLIENTNAME=" + D.Core.Configuration.clientName + "&SESSIONID=" + D.Core.JSRequest.sessionId + "T&CONFIG=" + L + "&P=" + D.Core.Configuration.projection;
                return K
            }
            var K = D.Core.Configuration.streetTileHosts[this.hostIdx] + M + "/openls/" + J + "/TILE?LLMIN=0.0,0.0&LLMAX=" + this._ll_LUT[D.Core.Configuration.projection][Math.round(O)] + "&CACHEABLE=true&DS=" + N + "&WIDTH=" + (256) + "&HEIGHT=" + (256) + "&CLIENTNAME=" + D.Core.Configuration.clientName + "&SESSIONID=" + D.Core.JSRequest.sessionId + "&FORMAT=PNG&CONFIG=" + L + "&N=" + P + "&E=" + Q + "&P=" + D.Core.Configuration.projection;
            this.hostIdx = (this.hostIdx + 1) % D.Core.Configuration.streetTileHosts.length;
            return K
        }
    };
    D.Core.TransparentTileStore.prototype = D.Utilities.inherit(D.Core.TransparentTileStore.prototype, D.Core.TileStore.prototype);
    D.Core.OverlayObject = function (K) {
        D.Core.EventableObject.call(this, K);
        this.useCSSTransforms = (D.Core.Configuration.useHardwareAcceleration && D.Window.hasCSSTransforms());
        this.renderingMode = "none";
        this.zIndex = 100;
        var L = H;
        if (D.Window.hasSVG() && !D.Window.isFirefox()) {
            this.renderingMode = "SVG"
        } else {
            if (D.Window.hasCanvas()) {
                this.renderingMode = "canvas"
            } else {
                if (D.Window.hasVML()) {
                    this.renderingMode = "VML"
                }
            }
        }
        if (this.renderingMode == "VML" && L.namespaces) {
            if (!L.namespaces.v) {
                L.namespaces.add("v", "urn:schemas-microsoft-com:vml", "#default#VML")
            }
            if (!L.styleSheets.deCarta_VML_Shapes) {
                var J = L.createStyleSheet();
                J.owningElement.id = "deCarta_VML_Shapes";
                J.cssText = "v\\: * { behavior:url(#default#VML); display:inline-block }"
            }
        }
    };
    D.Core.OverlayObject.prototype = {
        getPosition: function () {
            return this.options.position
        },
        setZIndex: function (J) {
            this.zIndex = J
        },
        getSize: function (J) {
            if (this.boundingBox) {
                return this.boundingBox.getSize(J)
            }
            if (!this.domElement) {
                return {
                    width: 0,
                    height: 0
                }
            }
            return {
                width: parseFloat(this.domElement.style.width),
                height: parseFloat(this.domElement.style.height)
            }
        },
        getIdealCenterAndZoom: function (J) {
            if (!this.boundingBox) {
                D.Core.Exception.raise("No bounding box!")
            }
            return this.boundingBox.getIdealCenterAndZoom(J)
        },
        getBoundingBox: function () {
            if (!this.boundingBox) {
                D.Core.Exception.raise("No bounding box!")
            }
            return this.boundingBox
        },
        setPosition: function (J) {
            this.options.position = new D.Core.Position(J.lat, J.lon);
            if (this.setBB) {
                this.setBB()
            }
            if (this.owner && this.owner.refreshObjects) {
                this.owner.refreshObjects()
            }
            if (this.owner && this.owner.owner) {
                this.owner.owner.render()
            }
        },
        domPosition: function (J, L, K) {
            this.domX = J;
            this.domY = L;
            if (!K) {
                K = this.domElement
            }
            J = Math.floor(J);
            L = Math.floor(L);
            if (!this.useCSSTransforms) {
                K.style.top = L + "px";
                K.style.left = J + "px"
            } else {
                K.style.top = "0px";
                K.style.left = "0px";
                K.style.webkitTransformOrigin = " 0 0 ";
                K.style.MozTransformOrigin = " 0 0 ";
                K.style.OTransformOrigin = " 0 0 ";
                K.style.msTransformOrigin = " 0 0 ";
                K.style.TransformOrigin = " 0 0 ";
                K.style.webkitTransform = "translate3d(" + J + "px, " + L + "px, 0)";
                K.style.msTransform = "translate3d(" + J + "px, " + L + "px, 0)";
                K.style.MozTransform = "translate3d(" + J + "px, " + L + "px, 0)";
                K.style.OTransform = "translate3d(" + J + "px, " + L + "px, 0)";
                K.style.Transform = "translate3d(" + J + "px, " + L + "px, 0)"
            }
        },
        registerOwner: function (J) {
            this.owner = J
        },
        setZoom: function (J) {},
        show: function () {
            this.visible = true;
            this.owner.refresh()
        },
        hide: function () {
            this.visible = false;
            this.owner.refresh()
        },
        toggle: function () {
            this.visible = !this.visible;
            this.owner.refresh()
        },
        touchStart: function (K, L) {
            if (this.options.opaque) {
                D.Touch.stopEvent(L)
            }
            if (!this.options.draggable) {
                return
            }
            this.dragging = true;
            this.dragged = false;
            this.startDragX = K.screenX;
            this.startDragY = K.screenY;
            if (this.options.onDrag) {
                this.options.onDrag.call(this, this.getCenter())
            }
            var J = this.owner.owner.positionFromXY(K.pageX, K.pageY);
            D.Touch.stopEvent(L)
        },
        touchEnd: function (K, L) {
            if (this.options.opaque) {
                D.Touch.stopEvent(L)
            }
            if (!this.options.draggable) {
                return
            }
            if (!this.dragging) {
                return
            }
            this.dragging = false;
            if (this.options.onDrop) {
                this.options.onDrop.call(this, this.getCenter())
            }
            var J = this.owner.owner.positionFromXY(K.screenX, K.screenY);
            if (this.dragged) {
                D.Core.EventManager.trigger("moveend", {
                    object: this,
                    event: K,
                    originalEvent: L,
                    eventPosition: J
                }, this)
            }
            D.Touch.stopEvent(L)
        },
        touchMove: function (N, P) {
            if (!this.dragging) {
                return
            }
            if (!this.dragged) {
                D.Core.EventManager.trigger("movestart", {
                    object: this,
                    event: N,
                    originalEvent: P,
                    eventPosition: L
                }, this);
                this.dragged = true
            }
            var K = N.screenX - this.startDragX;
            var J = N.screenY - this.startDragY;
            this.startDragX = N.screenX;
            this.startDragY = N.screenY;
            var M = this.getPosition().getPixelPoint(this.owner.owner.zoom);
            M.x += K;
            M.y -= J;
            var O = new D.Core.Position(0, 0);
            O.setXY(M.x, M.y, this.owner.owner.zoom);
            this.setPosition(O);
            this.owner.owner.render();
            var L = this.owner.owner.positionFromXY(N.pageX, N.pageY);
            D.Core.EventManager.trigger("move", {
                object: this,
                event: N,
                originalEvent: P,
                eventPosition: L
            }, this);
            D.Touch.stopEvent(P)
        }
    };
    D.Core.OverlayObject.prototype = D.Utilities.inherit(D.Core.OverlayObject.prototype, D.Core.EventableObject.prototype);
    D.Core.Pin = function (J) {
        D.Core.OverlayObject.call(this, J);
        this.options = {
            text: "",
            position: null,
            image: null,
            imageSrc: null,
            xOffset: 0,
            yOffset: 0,
            onClick: null,
            onLabelClick: null,
            onShowText: null,
            onHideText: null,
            cssClass: "",
            label: "",
            opaque: false,
            infoWinOptions: {
                autoReorient: true
            }
        };
        this.zIndex = 1;
        if (J.defaultPinOptions) {
            this.options.defaultPinOptions = D.Utilities.extendObject(this.options.defaultPinOptions, J.defaultPinOptions);
            delete J.defaultPinOptions
        }
        if (J.infoWinOptions) {
            this.options.infoWinOptions = D.Utilities.extendObject(this.options.infoWinOptions, J.infoWinOptions);
            delete J.infoWinOptions
        }
        this.options = D.Utilities.extendObject(this.options, J);
        this.type = "pin";
        this.domElement = null;
        this.textEnabled = true;
        this.visible = true
    };
    D.Core.Pin.prototype = {
        setImage: function (K, J, L) {
            this.options.image = K;
            if (J) {
                this.options.xOffset = J
            }
            if (L) {
                this.options.yOffset = L
            }
            if (this.domElement) {
                this._render(parseFloat(this.domElement.style.left), parseFloat(this.domElement.style.top), true)
            }
        },
        setImageSrc: function (L, J, K) {
            this.options.imageSrc = L;
            if (J) {
                this.options.xOffset = J
            }
            if (K) {
                this.options.yOffset = K
            }
            if (this.domElement) {
                this._render(parseFloat(this.domElement.style.left), parseFloat(this.domElement.style.top), true)
            }
        },
        getImage: function () {
            return (this.options.image || this.options.imageSrc)
        },
        setText: function (J) {
            this.options.text = J
        },
        setRotation: function (J) {
            this.pinImage.style.MozTransform = "rotate(-" + Math.round(J) + "deg)";
            this.pinImage.style.webkitTransform = "rotate(-" + Math.round(J) + "deg)";
            this.pinImage.style.WebkitTransform = "rotate(-" + Math.round(J) + "deg)";
            this.pinImage.style.oTransform = "rotate(-" + Math.round(J) + "deg)";
            this.pinImage.style.OTransform = "rotate(-" + Math.round(J) + "deg)"
        },
        hide: function () {
            if (this.domElement) {
                this.domElement.style.display = "none"
            }
            this.visible = false
        },
        show: function () {
            if (this.domElement) {
                this.domElement.style.display = "block"
            }
            this.visible = true
        },
        render: function (J, K) {
            if (!this.domElement) {
                this.domElement = this._render()
            }
            this.domPosition(J, K);
            if (this.textVisible) {
                this.showText()
            }
            return this.domElement
        },
        _render: function (J, M, K) {
            if (typeof K === "undefined") {
                K = false
            }
            if (!this.domElement) {
                this.domElement = D.crEl("div");
                this.domElement.style.position = "absolute";
                this.domElement.className = "deCarta-Pin " + this.options.cssClass;
                this.domElement.style.zIndex = this.zIndex;
                this.domElement.pin = this;
                this.domElement.id = ("deCarta-pin-" + Math.random()).replace(".", "")
            }
            if (this.options.imageSrc) {
                if (this.pinImage) {
                    D.Utilities.domRemove(this.pinImage);
                    delete this.pinImage
                }
                this.pinImage = new Image();
                this.pinImage.style.display = "none";
                this.pinImage.onload = function () {
                    this.style.display = "block";
                    if (!this.style.height) {
                        this.style.height = this.height + "px"
                    }
                    if (!this.style.width) {
                        this.style.width = this.width + "px"
                    }
                };
                this.pinImage.style.top = "-" + this.options.yOffset + "px";
                this.pinImage.style.left = "-" + this.options.xOffset + "px";
                this.pinImage.src = this.options.imageSrc
            } else {
                if (this.options.image) {
                    this.pinImage = this.options.image;
                    this.pinImage.style.top = "-" + this.options.yOffset + "px";
                    this.pinImage.style.left = "-" + this.options.xOffset + "px"
                } else {
                    var L = D.crEl("div");
                    this.domElement.className = "";
                    L.className = "deCarta-Pin-Default " + this.options.cssClass;
                    L.innerHTML = this.options.label;
                    this.pinImage = L
                }
            }
            this.pinImage.style.position = "absolute";
            if (!K) {
                this.addListeners(this.domElement)
            }
            this.domElement.appendChild(this.pinImage);
            D.Core.EventManager.listen("moveend", function () {
                if (this.textVisible && this.owner.owner.infoWindow.domElement.style.display != "none") {
                    this.owner.owner.infoWindow.position()
                }
            }.bind(this), this.owner.owner);
            if (!this.visible) {
                this.hide()
            }
            return this.domElement
        },
        tap: function (J, K) {
            this.triggerEvent("click", J, K);
            if (this.options.text) {
                if (this.textVisible) {
                    this.hideText()
                } else {
                    this.showText()
                }
            }
        },
        getBounds: function () {
            var L = this.domY;
            var K = this.domX;
            var J = parseFloat(D.Utilities.getStyle(this.pinImage, "top")) || 0;
            var M = parseFloat(D.Utilities.getStyle(this.pinImage, "left")) || 0;
            return {
                top: L + parseFloat(J),
                left: K + parseFloat(M),
                right: K + parseFloat(M) + this.pinImage.offsetWidth,
                bottom: L + parseFloat(J) + this.pinImage.offsetHeight,
                offsetX: K,
                offsetY: L
            }
        },
        getAnchorPositions: function () {
            var L = this.domY;
            var K = this.domX;
            var J = parseFloat(D.Utilities.getStyle(this.pinImage, "top")) || 0;
            var M = parseFloat(D.Utilities.getStyle(this.pinImage, "left")) || 0;
            return {
                left: (parseFloat(M) + parseFloat(this.pinImage.offsetWidth) / 2),
                right: (parseFloat(M) + parseFloat(this.pinImage.offsetWidth) / 2),
                top: parseFloat(J),
                bottom: parseFloat(J) + parseFloat(this.pinImage.offsetHeight)
            }
        },
        getCluster: function () {
            return (this.cluster ? (this.cluster.getList().length > 1 ? this.cluster : null) : null)
        },
        hideText: function () {
            if (!this.textVisible) {
                return
            }
            if (this.options.onHideText) {
                this.options.onHideText(this)
            }
            this.textVisible = false;
            this.domElement.style.zIndex = this.originalZ || 100;
            this.owner.owner.infoWindow.hide()
        },
        showText: function () {
            if (!this.textEnabled) {
                return
            }
            if (this.textVisible || !this.domElement) {
                return
            }
            if (this.options.onShowText) {
                this.options.onShowText(this)
            }
            this.originalZ = this.domElement.style.zIndex;
            this.domElement.style.zIndex = parseFloat(this.domElement.style.zIndex) + 100;
            var J = this.owner.owner.infoWindow.getElement();
            this.domElement.appendChild(J);
            this.owner.owner.infoWindow.show({
                target: this,
                content: this.options.text,
                autoReorient: this.options.infoWinOptions.autoReorient,
                cssClass: this.options.cssClass,
                onClose: function () {
                    this.domElement.style.zIndex = this.originalZ || 100;
                    if (this.options.onHideText) {
                        this.options.onHideText(this)
                    }
                    this.textVisible = false;
                    this.domElement.style.zIndex = this.originalZ || 100
                }.bind(this)
            });
            if (this.options.onTextShown) {
                this.options.onTextShown(this)
            }
            this.owner.owner.render();
            this.textVisible = true
        },
        disableText: function () {
            this.hideText();
            this.textEnabled = false
        },
        enableText: function () {
            this.textEnabled = true
        },
        getCenter: function () {
            return this.options.position
        }
    };
    D.Core.Pin.prototype = D.Utilities.inherit(D.Core.Pin.prototype, D.Core.OverlayObject.prototype);
    D.Core.Image = function (J) {
        D.Core.OverlayObject.call(this, J);
        this.options = {
            topLeft: null,
            btmRight: null,
            minZoom: 1,
            maxZoom: 21,
            width: 0,
            height: 0,
            cssClass: "deCarta-Mob-ImgObj",
            opacity: 75
        };
        this.domElement = null;
        this.type = "image";
        this.options = D.Utilities.extendObject(this.options, J);
        this.boundingBox = new D.Core.BoundingBox([this.options.topLeft, this.options.btmRight])
    };
    D.Core.Image.prototype = {
        render: function (K, O, N, L) {
            if (N >= this.options.minZoom && N <= this.options.maxZoom) {
                if (!this.domElement) {
                    this.domElement = new Image();
                    this.domElement.style.position = "absolute";
                    this.domElement.src = this.options.src;
                    this.domElement.className = this.options.cssClass;
                    D.Utilities.setOpacity(this.domElement, this.options.opacity);
                    this.addListeners(this.domElement)
                }
                this.domElement.style.display = "block";
                this.domElement.style.top = O + "px";
                this.domElement.style.left = K + "px";
                var M = D.Utilities.lon2pix(this.options.btmRight.getLon(), N) - D.Utilities.lon2pix(this.options.topLeft.getLon(), N);
                var J = D.Utilities.lat2pix(this.options.topLeft.getLat(), N) - D.Utilities.lat2pix(this.options.btmRight.getLat(), N);
                this.domElement.style.width = M + "px";
                this.domElement.style.height = J + "px";
                this.domElement.style.zIndex = 100;
                return this.domElement
            } else {
                this.domElement.style.display = "none"
            }
        },
        getPosition: function () {
            return this.options.topLeft
        },
        getSize: function (J) {
            return this.boundingBox.getSize(J)
        },
        setPosition: function (L) {
            z = 21;
            var N = D.Utilities.lon2pix(this.options.btmRight.getLon(), z) - D.Utilities.lon2pix(this.options.topLeft.getLon(), z);
            var K = D.Utilities.lat2pix(this.options.topLeft.getLat(), z) - D.Utilities.lat2pix(this.options.btmRight.getLat(), z);
            this.options.topLeft = new D.Core.Position(L.lat, L.lon);
            var M = D.Utilities.lon2pix(this.options.topLeft.getLon(), z) + N;
            var J = D.Utilities.lat2pix(this.options.topLeft.getLat(), z) - K;
            this.options.btmRight.setXY(M, J, z);
            if (this.owner && this.owner.refreshObjects) {
                this.owner.refreshObjects()
            }
        }
    };
    D.Core.Image.prototype = D.Utilities.inherit(D.Core.Image.prototype, D.Core.OverlayObject.prototype);
    D.Core.ClusteredPin = function (J) {
        D.Core.OverlayObject.call(this, J);
        this.options = {
            threshold: 50,
            zoom: null,
            image: null,
            imageSrc: null,
            xOffset: 0,
            yOffset: 0,
            onClick: function () {}
        };
        this.options = D.Utilities.extendObject(this.options, J);
        if (!this.options.zoom) {
            D.Core.Exception.raise("You cannot instantiate a ClusteredPin without specifying the zoom")
        }
        this.pin = null;
        this.cluster = null;
        this.point = null;
        this.threshold = this.options.threshold;
        this.domElement = null
    };
    D.Core.ClusteredPin.prototype = {
        addPin: function (K) {
            if (!this.cluster) {
                this.cluster = [];
                this.cluster.push(K);
                this.options.position = K.getPosition();
                this.centerPoint = this.options.position.getPixelPoint(this.options.zoom);
                K.cluster = this;
                return true
            } else {
                var J = K.getPosition().getPixelPoint(this.options.zoom);
                if (D.Utilities.pixelDistance(this.centerPoint, J) < this.options.threshold) {
                    this.cluster.push(K);
                    K.cluster = this;
                    return true
                } else {
                    return false
                }
            }
        },
        getCount: function () {
            var K = 0;
            for (var J = 0; J < this.cluster.length; J++) {
                if (this.cluster[J] && this.cluster[J].visible) {
                    K++
                }
            }
            return K
        },
        zoomDownToBreakPinFromCluster: function (J, S, R) {
            var L = null;
            var Q = parseFloat("Infinity");
            for (var M = 0; M < this.cluster.length; M++) {
                if (J.objectId !== this.cluster[M].objectId) {
                    var O = D.Utilities.positionPixelDistance(J.getPosition(), this.cluster[M].getPosition(), 19);
                    if (O < Q) {
                        L = this.cluster[M];
                        Q = O
                    }
                }
            }
            if (Q <= this.options.threshold) {
                R();
                return
            }
            var K = J.owner.owner.zoom;
            for (var P = K; P <= 19; P++) {
                var O = D.Utilities.positionPixelDistance(J.getPosition(), L.getPosition(), P);
                if (O > this.options.threshold) {
                    var N = function (T) {
                        D.Core.EventManager.stopListening("zoomend", this.handley);
                        setTimeout(S, 100)
                    }.bind(this);
                    this.handley = D.Core.EventManager.listen("zoomend", N, J.owner.owner);
                    J.owner.owner.centerOn(J.getPosition(), {
                        animated: false
                    });
                    J.owner.owner.zoomTo(P);
                    return
                }
            }
        },
        getSingle: function (J, L) {
            for (var K = 0; K < this.cluster.length; K++) {
                if (this.cluster[K].visible) {
                    break
                }
            }
            return this.cluster[K].render(J, L)
        },
        render: function (J, M) {
            var K = this.getCount();
            if (K == 1) {
                return this.getSingle(J, M)
            }
            var L = this.cluster[0].zIndex;
            if (!this.domElement) {
                this.domElement = D.crEl("div");
                this.domElement.className = "deCarta-Pin-Cluster";
                this.domElement.style.zIndex = L;
                this.domElement.id = ("deCarta-pin-" + Math.random()).replace(".", "");
                this.domElement.style.position = "absolute";
                this.imgElement = this.chooseIcon();
                this.imgElement.style.position = "absolute;";
                this.labelElement = D.crEl("div");
                this.labelElement.className = "deCarta-Pin-Cluster-label";
                this.domElement.appendChild(this.imgElement);
                this.domElement.appendChild(this.labelElement);
                D.Touch.attachListener("tap", this.domElement, this.onClick.bind(this), false)
            }
            this.domPosition(J - this.options.xOffset, M - this.options.yOffset);
            this.labelElement.innerHTML = K;
            this.domElement.style.display = (K > 0) ? "block" : "none";
            return this.domElement
        },
        genericClusterIcon: function (J) {
            var K = D.crEl("div");
            K.className = "deCarta-Pin-Cluster-Default";
            return K
        },
        chooseIcon: function () {
            if (this.options.image) {
                return this.options.image
            }
            if (this.options.imageSrc) {
                var J = new Image();
                J.src = this.options.imageSrc;
                return J
            }
            var L = this.cluster[0].getImage();
            if (L) {
                for (var K = 1; K < this.cluster.length; K++) {
                    if (typeof L !== "string") {
                        if (this.cluster[K].getImage().src != L.src) {
                            return this.genericClusterIcon(this.cluster[K])
                        }
                    } else {
                        if (this.cluster[K].getImage() != L) {
                            return this.genericClusterIcon(this.cluster[K])
                        }
                    }
                }
                var J = new Image();
                if (typeof L === "string") {
                    J.src = L
                } else {
                    J.src = L.src;
                    J.style.width = L.style.width;
                    J.style.height = L.style.height
                }
                this.options.xOffset = this.cluster[0].options.xOffset;
                this.options.yOffset = this.cluster[0].options.yOffset
            } else {
                return this.genericClusterIcon(this.cluster[K])
            }
            return J
        },
        onClick: function () {
            this.options.onClick(this.cluster)
        },
        getList: function () {
            return this.cluster
        },
        getBounds: function () {
            var L = this.domY;
            var K = this.domX;
            var J = parseFloat(D.Utilities.getStyle(this.imgElement, "top")) || 0;
            var M = parseFloat(D.Utilities.getStyle(this.imgElement, "left")) || 0;
            return {
                top: L + parseFloat(J),
                left: K + parseFloat(M),
                right: K + parseFloat(M) + this.imgElement.offsetWidth,
                bottom: L + parseFloat(J) + this.imgElement.offsetHeight,
                offsetX: K,
                offsetY: L
            }
        },
        getAnchorPositions: function () {
            var L = this.domY;
            var K = this.domX;
            var J = parseFloat(D.Utilities.getStyle(this.imgElement, "top")) || 0;
            var M = parseFloat(D.Utilities.getStyle(this.imgElement, "left")) || 0;
            return {
                left: (parseFloat(M) + parseFloat(this.imgElement.offsetWidth) / 2),
                right: (parseFloat(M) + parseFloat(this.imgElement.offsetWidth) / 2),
                top: parseFloat(J),
                bottom: parseFloat(J) + parseFloat(this.imgElement.offsetHeight)
            }
        },
        showText: function (M, J, K) {
            this.originalZ = this.domElement.style.zIndex;
            this.domElement.style.zIndex = parseFloat(this.domElement.style.zIndex) + 100;
            var L = this.owner.owner.infoWindow.getElement();
            this.domElement.appendChild(L);
            this.owner.owner.infoWindow.show({
                target: this,
                content: M,
                autoReorient: true,
                onClose: function () {
                    this.domElement.style.zIndex = this.originalZ || 100;
                    if (J) {
                        J(this)
                    }
                    this.textVisible = false;
                    this.domElement.style.zIndex = this.originalZ || 100
                }.bind(this)
            })
        },
        hideText: function () {
            this.domElement.style.zIndex = this.originalZ || 100;
            this.owner.owner.infoWindow.hide()
        }
    };
    D.Core.ClusteredPin.prototype = D.Utilities.inherit(D.Core.ClusteredPin.prototype, D.Core.OverlayObject.prototype);
    D.Core.Shape = function (J) {
        D.Core.OverlayObject.call(this, J);
        this.options = {
            strokeColor: "#0077D2",
            strokeWidth: 2,
            strokeOpacity: 0.7,
            fillColor: "#0077D2",
            fillOpacity: 0.4
        };
        this.options = D.Utilities.extendObject(this.options, J);
        this.type = "shape";
        this.padding = 5;
        this.attachedEvents = false;
        this.visible = true
    };
    D.Core.Shape.prototype = {
        render: function (J, N, M, K) {
            if (!this.visible) {
                return
            }
            var L = null;
            switch (this.renderingMode) {
                case "canvas":
                    L = this.renderCanvas(J, N, M, K);
                    break;
                case "SVG":
                    L = this.renderSVG(J, N, M, K);
                    break;
                case "VML":
                    L = this.renderVML(J, N, M, K);
                    break
            }
            return L
        }
    };
    D.Core.Shape.prototype = D.Utilities.inherit(D.Core.Shape.prototype, D.Core.OverlayObject.prototype);
    D.Core.Polyline = function (J) {
        opts = {
            lineGeometry: null,
            strokeWidth: 6,
            granularity: 7
        };
        J = D.Utilities.extendObject(opts, J);
        D.Core.Shape.call(this, J);
        if (!J.lineGeometry || J.lineGeometry.length == 0) {
            D.Core.Exception.raise("You need to provide a lineGeometry to instantiate a polyline")
        }
        this.pointIndex = [];
        this.genGeom = [];
        this.positions = [];
        this.lastRenderedPointSet = null;
        if (typeof this.options.lineGeometry[0] == "object" && this.options.lineGeometry[0].getLat) {
            this.positions = this.options.lineGeometry.slice()
        } else {
            for (var K = 0; K < this.options.lineGeometry.length; K++) {
                var L = this.options.lineGeometry[K].split(" ");
                var M = new D.Core.Position(L[0], L[1]);
                this.positions.push(M)
            }
        }
        this.type = "shape";
        this.padding = 5;
        this.findBounds();
        this.boundingBox = new D.Core.BoundingBox(this.positions)
    };
    D.Core.Polyline.prototype = {
        getPosition: function () {
            return this.topLeftPoint
        },
        setPosition: function (J) {
            this.topLeftPoint = J
        },
        getSize: function (J) {
            return this.boundingBox.getSize(J)
        },
        getGML: function () {
            var J = "";
            J += "<gml:LineString>";
            for (i = 0; i < this.options.lineGeometry.length; i++) {
                J += "<gml:pos>" + this.options.lineGeometry[i] + "</gml:pos>"
            }
            J += "</gml:LineString>";
            return J
        },
        getIdealCenterAndZoom: function (J) {
            return this.boundingBox.getIdealCenterAndZoom(J)
        },
        renderVML: function (U, S, R, W) {
            if (!this.container) {
                this.findBounds();
                this.container = D.crEl("div");
                this.container.id = ("deCarta-polyline-container-" + Math.random()).replace(".", "");
                this.container.style.position = "absolute";
                return this.container
            }
            this.findBounds();
            this.indexAndThinPoints(R);
            var O = D.Utilities.normalizeZoom(R);
            var P = "";
            var M = this.topLeftPoint.getX(R);
            var L = this.topLeftPoint.getY(R);
            var V = this.preparePoints(R, M, L, W);
            for (var N = 0; N < V.length; N++) {
                var J = V[N];
                P += Math.round(J.x) + "," + Math.round(J.y) + " "
            }
            var Q = '<v:fill opacity="0%" color="' + this.options.fillColor + '"/>';
            var T = '<v:stroke opacity="' + Math.round(this.options.strokeOpacity * 100) + '%" weight="' + this.options.strokeWidth + 'px" color="' + this.options.strokeColor + '" />';
            var K = '<v:polyline points="' + P + '">' + T + Q + "</v:polyline>";
            this.container.style.zIndex = this.zIndex;
            this.container.innerHTML = K;
            this.clickableElement = this.container.firstChild;
            this.domPosition((U - 5), (S - 5), this.container);
            return this.container
        },
        renderSVG: function (S, R, Q, U) {
            if (!this.svgElement) {
                this.findBounds();
                this.svgElement = H.createElementNS("http://www.w3.org/2000/svg", "svg");
                this.svgElement.setAttribute("version", "1.1");
                this.svgElement.setAttribute("id", ("deCarta-shape-svg-" + Math.random()).replace(".", ""))
            }
            if (!this.lineElement) {
                this.lineElement = H.createElementNS("http://www.w3.org/2000/svg", "polyline");
                this.svgElement.appendChild(this.lineElement)
            }
            this.indexAndThinPoints(Q);
            var N = D.Utilities.normalizeZoom(Q);
            var P = "";
            var L = this.topLeftPoint.getX(Q);
            var K = this.topLeftPoint.getY(Q);
            var T = this.preparePoints(Q, L, K, U);
            for (var M = 0; M < T.length; M++) {
                var J = T[M];
                P += J.x + "," + J.y + " "
            }
            this.lineElement.setAttribute("points", P);
            this.lineElement.setAttribute("style", "fill:none;stroke:" + this.options.strokeColor + ";stroke-width:" + this.options.strokeWidth + ";stroke-opacity:" + this.options.strokeOpacity);
            var O = this.getSize(Q);
            this.svgElement.setAttribute("style", "position: absolute; width: " + (O.width + 10) + "px; height: " + (O.height + 10) + "px;");
            this.svgElement.style.zIndex = this.zIndex;
            this.domPosition((S - 5), (R - 5), this.svgElement);
            this.clickableElement = this.lineElement;
            return this.svgElement
        },
        renderCanvas: function (S, R, P, V) {
            if (!this.canvasElement) {
                this.findBounds();
                this.canvasElement = D.crEl("canvas");
                this.canvasElement.setAttribute("id", ("deCarta-shape-" + Math.random()).replace(".", ""));
                this.canvasElement.className = "deCarta-polyline";
                this.canvasElement.style.zIndex = this.zIndex;
                this.canvasElement.style.position = "absolute";
                return this.canvasElement
            }
            if (!this.canvasElement.getContext) {
                try {
                    G_vmlCanvasManager.initElement(this.canvasElement)
                } catch (O) {
                    D.Core.Exception.raise("Error in drawing the shape - have you added exCanvas to your page?")
                }
            }
            this.indexAndThinPoints(P);
            var N = this.getSize(P);
            var U = 0;
            var J = 0;
            if (S < 0) {
                J = S;
                S = 0
            }
            if (R < 0) {
                U = R;
                R = 0
            }
            if (S + N.width > G.innerWidth) {
                N.width = G.innerWidth - S
            }
            if (R + N.height > G.innerHeight) {
                N.height = G.innerHeight - R
            }
            this.domPosition((S - this.padding), (R - this.padding), this.canvasElement);
            if (P == this.lastZ && J == this.lastLeftClip && U == this.lastTopClip && N.width == this.lastWidth && N.height == this.lastHeight) {
                return this.canvasElement
            }
            this.lastZ = P;
            this.lastLeftClip = J;
            this.lastTopClip = U;
            this.lastWidth = N.width;
            this.lastHeight = N.height;
            this.canvasElement.width = N.width + (this.padding * 2);
            this.canvasElement.height = N.height + (this.padding * 2);
            var L = this.topLeftPoint.getX(P) - J;
            var K = this.topLeftPoint.getY(P) + U;
            var W = this.canvasElement.getContext("2d");
            W.beginPath();
            var T = this.preparePoints(P, L, K, V);
            var Q = false;
            for (var M = 0; M < T.length; M++) {
                p = T[M];
                if (!Q) {
                    W.moveTo(p.x, p.y);
                    Q = true
                } else {
                    W.lineTo(p.x, p.y)
                }
            }
            W.strokeStyle = this.options.strokeColor;
            W.lineWidth = this.options.strokeWidth;
            W.globalAlpha = this.options.strokeOpacity;
            W.lineCap = "round";
            W.stroke();
            return this.canvasElement
        },
        indexAndThinPoints: function (P) {
            var Z = D.Utilities.normalizeZoom(P);
            if (!this.pointIndex[Z]) {
                var e = null;
                var f = null;
                var g = this.positions.length;
                var L = null;
                var c = 0;
                var a = 0;
                var M = null;
                var d = null;
                var b = null;
                this.pointIndex[Z] = {};
                this.genGeom[Z] = [];
                for (var V = 0; V < g; V++) {
                    var U = this.positions[V];
                    c = U.getX(P);
                    a = U.getY(P);
                    if (L) {
                        M = Math.sqrt(Math.pow(c - L.x, 2) + Math.pow(a - L.y, 2))
                    }
                    if (M > this.options.granularity || !L || V == (g - 1)) {
                        e = U.getTileAtZoom(Z);
                        f = D.Utilities.getTileKey(e.E, e.N, Z);
                        if (!this.pointIndex[Z][f]) {
                            this.pointIndex[Z][f] = []
                        }
                        this.genGeom[Z].push(V);
                        this.pointIndex[Z][f].push(this.genGeom[Z].length - 1);
                        if (d && b) {
                            if (e.E != d || e.N != b) {
                                var Y = Math.min(e.E, d);
                                var X = Math.max(e.E, d);
                                var K = Math.min(e.N, b);
                                var J = Math.max(e.N, b);
                                var R = Math.abs(X - Y);
                                var Q = Math.abs(J - K);
                                var T = (Y < X) ? 1 : -1;
                                var S = (K < J) ? 1 : -1;
                                var N = R - Q;
                                while (true) {
                                    var W = D.Utilities.getTileKey(Y, K, Z);
                                    if (!this.pointIndex[Z][W]) {
                                        this.pointIndex[Z][W] = []
                                    }
                                    this.pointIndex[Z][W].push(this.genGeom[Z].length - 1);
                                    this.pointIndex[Z][W].push(this.genGeom[Z].length - 2);
                                    if ((Y == X) && (K == J)) {
                                        break
                                    }
                                    var O = 2 * N;
                                    if (O > -Q) {
                                        N -= Q;
                                        Y += T
                                    }
                                    if (O < R) {
                                        N += R;
                                        K += S
                                    }
                                }
                            }
                        }
                        d = e.E;
                        b = e.N;
                        L = {
                            x: c,
                            y: a
                        }
                    }
                }
            }
        },
        preparePoints: function (P, M, K, U) {
            var T = [];
            var O = D.Utilities.normalizeZoom(P);
            var J = null;
            var R = null;
            var Q = null;
            var V = {};
            for (var N = 0; N < U.length; N++) {
                var S = D.Utilities.getTileKey(U[N].E, U[N].N, O);
                if (this.pointIndex[O][S]) {
                    for (var L = 0; L < this.pointIndex[O][S].length; L++) {
                        J = this.positions[this.genGeom[O][this.pointIndex[O][S][L]]];
                        R = J.getX(P) - M + this.padding;
                        Q = K - J.getY(P) + this.padding;
                        if (!V[J.toString()]) {
                            V[J.toString()] = true;
                            T.push({
                                x: R,
                                y: Q,
                                i: this.pointIndex[O][S][L]
                            })
                        }
                    }
                }
            }
            T.sort(function (X, W) {
                return X.i - W.i
            });
            return T
        },
        findBounds: function () {
            this.topLeftPoint = null;
            this.btmRightPoint = null;
            var J = null;
            var Q = null;
            var P = null;
            var N = null;
            for (var M = 0; M < this.positions.length; M++) {
                var O = this.positions[M];
                var L = O.getX(18);
                var K = O.getY(18);
                if (L < J || !J) {
                    J = L
                }
                if (K < Q || !Q) {
                    Q = K
                }
                if (L > P || !P) {
                    P = L
                }
                if (K > N || !N) {
                    N = K
                }
            }
            this.topLeftPoint = new D.Core.Position(0, 0);
            this.btmRightPoint = new D.Core.Position(0, 0);
            this.topLeftPoint.setXY(J, N, 18);
            this.btmRightPoint.setXY(P, Q, 18);
            this.boundingBox = new D.Core.BoundingBox([this.topLeftPoint, this.btmRightPoint])
        },
        shouldProcessEvent: function (K, J, O) {
            if (this.renderingMode == "canvas") {
                var L = this.canvasElement.getContext("2d");
                try {
                    var N = L.getImageData(J, O, 2, 2).data
                } catch (M) {
                    return false
                }
                if (N[0] == 0 && N[1] == 0 && N[2] == 0) {
                    return false
                }
                return true
            }
            return true
        },
        getBoundingBox: function () {
            return this.boundingBox
        }
    };
    D.Core.Polyline.prototype = D.Utilities.inherit(D.Core.Polyline.prototype, D.Core.Shape.prototype);
    D.Core.Polygon = function (J) {
        D.Core.Shape.call(this, J);
        opts = {
            draggable: false,
            scroll: null
        };
        this.options = D.Utilities.extendObject(opts, this.options);
        this.lastRenderedZ = 0;
        if (this.options.vertices.length < 3) {
            D.Core.Exception.raise("Instantiating a polygon with too few vertices. I believe you need at least 3.")
        }
        this.boundingBox = new D.Core.BoundingBox(this.options.vertices);
        this.getPosition()
    };
    D.Core.Polygon.prototype = {
        getPosition: function () {
            var L = null;
            var M = null;
            for (var K = 0; K < this.options.vertices.length; K++) {
                var J = this.options.vertices[K];
                if (!L || J.lat > L) {
                    L = J.lat
                }
                if (!M || J.lon < M) {
                    M = J.lon
                }
            }
            this.position = new D.Core.Position(L, M);
            return this.position
        },
        getGML: function () {
            var J = "";
            J += "<gml:Polygon><gml:exterior><gml:LinearRing>";
            for (i = 0; i < this.options.vertices.length; i++) {
                J += "<gml:pos>" + this.options.vertices[i] + "</gml:pos>"
            }
            J += "</gml:LinearRing></gml:exterior></gml:Polygon>";
            return J
        },
        setPosition: function (Q) {
            var M = this.position.getPixelPoint();
            var O = Q.getPixelPoint();
            var K = M.x - O.x;
            var J = M.y - O.y;
            for (var N = 0; N < this.options.vertices.length; N++) {
                var L = this.options.vertices[N];
                var P = L.getPixelPoint();
                P.x = P.x - K;
                P.y = P.y - J;
                L.setXY(P.x, P.y)
            }
            if (this.boundary) {
                this.boundary.fromPoly(this)
            }
            this.position = Q
        },
        getCenter: function () {
            var N = this.getPosition().getPixelPoint();
            var L = this.getSize(21);
            var K = N.x + (L.width / 2);
            var M = N.y - (L.height / 2);
            var J = new D.Core.Position(0, 0);
            J.setXY(K, M, 21);
            return J
        },
        getSize: function (J) {
            return this.boundingBox.getSize(J)
        },
        getBoundingBox: function () {
            return this.boundingBox
        },
        setVertices: function (J) {
            this.options.vertices = J;
            this.boundingBox = new D.Core.BoundingBox(J)
        },
        contains: function (J) {
            if (!J.getLon) {
                if (J.getCenter) {
                    J = J.getCenter()
                } else {
                    throw new D.Core.Exception('The position passed to the "contains" function is not a position.')
                }
            }
            if (!this.boundary) {
                this.boundary = new D.Core.MapBoundary();
                this.boundary.fromPoly(this)
            }
            return this.boundary.checkPosition(J)
        },
        shouldProcessEvent: function (J) {
            return this.contains(J)
        },
        renderCanvas: function (R, P, N, T) {
            if (!this.canvasElement) {
                this.canvasElement = D.crEl("canvas");
                this.canvasElement.setAttribute("id", ("deCarta-shape-" + Math.random()).replace(".", ""));
                this.canvasElement.className = "deCarta-polygon";
                this.canvasElement.style.zIndex = this.zIndex;
                this.canvasElement.style.position = "absolute";
                return this.canvasElement
            }
            if (!this.canvasElement.getContext) {
                try {
                    G_vmlCanvasManager.initElement(this.canvasElement)
                } catch (M) {
                    D.Core.Exception.raise("Error in drawing the shape - have you added exCanvas to your page?")
                }
            }
            var X = this.getSize(N);
            this.domPosition((R - this.padding), (P - this.padding), this.canvasElement);
            if (N == this.lastRenderedZ) {}
            var K = X.width + (this.padding * 2);
            var Q = X.height + (this.padding * 2);
            if (K != this.canvasElement.width || Q != this.canvasElement.height) {
                this.canvasElement.width = K;
                this.canvasElement.height = Q;
                var V = this.canvasElement.getContext("2d");
                V.strokeStyle = D.Utilities.makeRGBA(this.options.strokeColor, this.options.strokeOpacity);
                V.lineWidth = this.options.strokeWidth;
                V.fillStyle = D.Utilities.makeRGBA(this.options.fillColor, this.options.fillOpacity);
                V.beginPath();
                var J = this.getPosition().getPixelPoint(N);
                for (var L = 0; L < this.options.vertices.length; L++) {
                    var S = this.options.vertices[L];
                    var O = S.getPixelPoint(N);
                    var W = O.x - J.x + this.padding;
                    var U = J.y - O.y + this.padding;
                    if (L == 0) {
                        V.moveTo(W, U)
                    } else {
                        V.lineTo(W, U)
                    }
                }
                V.closePath();
                V.fill();
                V.stroke()
            }
            this.lastRenderedZ = N;
            return this.canvasElement
        },
        renderVML: function (T, Q, O) {
            if (!this.container) {
                this.container = D.crEl("div");
                this.container.id = ("deCarta-polygon-container-" + Math.random()).replace(".", "");
                this.container.style.zIndex = this.zIndex;
                this.container.style.position = "absolute";
                return this.container
            }
            var J = this.getPosition().getPixelPoint(O);
            var Y = this.getSize(O);
            var K = Y.width + (this.padding * 2);
            var R = Y.height + (this.padding * 2);
            var W = "m ";
            for (var L = 0; L < this.options.vertices.length; L++) {
                var U = this.options.vertices[L];
                var P = U.getPixelPoint(O);
                var X = P.x - J.x + this.padding;
                var V = J.y - P.y + this.padding;
                if (L == 1) {
                    W += "l "
                }
                W += Math.round(X) + "," + Math.round(V) + " "
            }
            W += "x e";
            var N = '<v:fill opacity="' + Math.round(this.options.fillOpacity * 100) + '%" color="' + this.options.fillColor + '"/>';
            var S = '<v:stroke opacity="' + Math.round(this.options.strokeOpacity * 100) + '%" weight="' + this.options.strokeWidth + 'px" color="' + this.options.strokeColor + '" />';
            var M = '<v:shape coordsize="' + K + "," + R + '" style="position:absolute;width:' + K + "px;height:" + R + 'px;" path="' + W + '"> ' + N + S + "</v:shape>";
            this.domPosition((T - this.padding), (Q - this.padding), this.container);
            this.container.innerHTML = M;
            return this.container
        },
        renderSVG: function (R, P, N, T) {
            if (!this.svgElement) {
                this.container = D.crEl("div");
                this.container.id = ("deCarta-polygon-container-" + Math.random()).replace(".", "");
                this.svgElement = H.createElementNS("http://www.w3.org/2000/svg", "svg");
                this.svgElement.setAttribute("version", "1.1");
                this.svgElement.setAttribute("id", ("deCarta-polygon-svg-" + Math.random()).replace(".", ""));
                this.container.style.zIndex = this.zIndex;
                this.container.style.position = "absolute";
                this.container.appendChild(this.svgElement);
                return this.container
            }
            if (!this.polyElement) {
                this.polyElement = H.createElementNS("http://www.w3.org/2000/svg", "polygon");
                this.svgElement.appendChild(this.polyElement)
            }
            var J = this.getPosition().getPixelPoint(N);
            var W = this.getSize(N);
            var K = W.width + (this.padding * 2);
            var Q = W.height + (this.padding * 2);
            var M = "";
            for (var L = 0; L < this.options.vertices.length; L++) {
                var S = this.options.vertices[L];
                var O = S.getPixelPoint(N);
                var V = O.x - J.x + this.padding;
                var U = J.y - O.y + this.padding;
                M += V + "," + U + " "
            }
            this.polyElement.setAttribute("points", M);
            this.polyElement.setAttribute("fill-opacity", this.options.fillOpacity);
            this.polyElement.setAttribute("stroke-opacity", this.options.strokeOpacity);
            this.polyElement.setAttribute("style", "fill:" + this.options.fillColor + ";stroke:" + this.options.strokeColor + ";stroke-width:" + this.options.strokeWidth + ";position: absolute;");
            this.container.style.width = K + "px";
            this.container.style.height = Q + "px";
            this.domPosition((R - this.padding), (P - this.padding), this.container);
            return this.container
        }
    };
    D.Core.Polygon.prototype = D.Utilities.inherit(D.Core.Polygon.prototype, D.Core.Shape.prototype);
    D.Core.Circle = function (J) {
        D.Core.Shape.call(this, J);
        opts = {
            position: null,
            radius: 500
        };
        this.options = D.Utilities.extendObject(opts, this.options);
        if (!this.options.position) {
            D.Core.Exception.raise("Instantiating a circle without a position. You can see how this would not work very well. Please pass the center position as one of the options, like this: new deCarta.Core.Circle({position: new Position(37, -122)});")
        }
        this.setBB()
    };
    D.Core.Circle.prototype = {
        setRadius: function (J) {
            this.options.radius = J;
            this.setBB()
        },
        setBB: function () {
            var M = this.getPixelRadius(21);
            var J = this.options.position.getX(21);
            var N = this.options.position.getY(21);
            var K = new D.Core.Position(0, 0);
            var L = new D.Core.Position(0, 0);
            K.setXY(J - M, N + M, 21);
            L.setXY(J + M, N - M, 21);
            this.boundingBox = new D.Core.BoundingBox([K, L])
        },
        getBoundingBox: function () {
            return this.boundingBox
        },
        contains: function (K) {
            if (!K.getLon) {
                if (K.getCenter) {
                    K = K.getCenter()
                } else {
                    throw new D.Core.Exception('The position passed to the "contains" function is not a position.')
                }
            }
            var J = D.Utilities.getPointDistance(this.options.position, K) * 1000;
            return (J <= this.options.radius)
        },
        shouldProcessEvent: function (J) {
            return this.contains(J)
        },
        getRadius: function () {
            return this.options.radius
        },
        getGML: function () {
            var J = "";
            J += "<gml:CircleByCenterPoint numArc='1'>";
            J += "<gml:pos>" + this.options.position + "</gml:pos>";
            J += "<gml:radius uom='m'>" + this.options.radius + "</gml:radius>";
            J += "</gml:CircleByCenterPoint>";
            return J
        },
        getPixelRadius: function (J) {
            return 1 / (D.Utilities.metersPerPixelAtZoom(this.options.position, J) * (1 / this.options.radius))
        },
        renderCanvas: function (Q, P, N, R) {
            if (!this.canvasElement) {
                this.canvasElement = D.crEl("canvas");
                this.canvasElement.setAttribute("id", ("deCarta-shape-" + Math.random()).replace(".", ""));
                this.canvasElement.className = "deCarta-circle";
                this.canvasElement.style.zIndex = this.zIndex;
                this.canvasElement.style.position = "absolute";
                return this.canvasElement
            }
            if (!this.canvasElement.getContext) {
                try {
                    G_vmlCanvasManager.initElement(this.canvasElement)
                } catch (L) {
                    D.Core.Exception.raise("Error in drawing the shape - have you added exCanvas to your page?")
                }
            }
            var M = D.Window.getViewport();
            var O = this.getPixelRadius(N);
            this.domPosition((Q - this.padding - O), (P - this.padding - O), this.canvasElement);
            if (Q + O < 0 || P + O < 0 || Q - O > M.width || P - O > M.height) {
                return false
            }
            var K = (O * 2) + (this.padding * 2);
            var J = (O * 2) + (this.padding * 2);
            if (this.canvasElement.width != K || this.canvasElement.height != J) {
                this.canvasElement.width = (O * 2) + (this.padding * 2);
                this.canvasElement.height = (O * 2) + (this.padding * 2);
                var S = this.canvasElement.getContext("2d");
                S.beginPath();
                S.arc(O + this.padding, O + this.padding, O, 0, Math.PI * 2, true);
                S.closePath();
                S.strokeStyle = D.Utilities.makeRGBA(this.options.strokeColor, this.options.strokeOpacity);
                S.lineWidth = this.options.strokeWidth;
                S.fillStyle = D.Utilities.makeRGBA(this.options.fillColor, this.options.fillOpacity);
                S.fill();
                S.stroke()
            }
            return this.canvasElement
        },
        renderSVG: function (K, Q, P, M) {
            if (!this.svgElement) {
                this.container = D.crEl("div");
                this.container.id = ("deCarta-circle-container-" + Math.random()).replace(".", "");
                this.svgElement = H.createElementNS("http://www.w3.org/2000/svg", "svg");
                this.svgElement.setAttribute("version", "1.1");
                this.svgElement.setAttribute("id", ("deCarta-circle-svg-" + Math.random()).replace(".", ""));
                this.container.style.zIndex = this.zIndex;
                this.container.style.position = "absolute";
                this.container.appendChild(this.svgElement);
                return this.container
            }
            if (!this.circleElement) {
                this.circleElement = H.createElementNS("http://www.w3.org/2000/svg", "circle");
                this.svgElement.appendChild(this.circleElement)
            }
            var J = D.Window.getViewport();
            var O = this.getPixelRadius(P);
            if (K + O < 0 || Q + O < 0 || K - O > J.width || Q - O > J.height) {
                return false
            }
            var N = (O * 2) + (this.padding * 2);
            var L = (O * 2) + (this.padding * 2);
            this.container.style.width = N + "px";
            this.container.style.height = L + "px";
            this.circleElement.setAttribute("cx", N / 2);
            this.circleElement.setAttribute("cy", L / 2);
            this.circleElement.setAttribute("r", O);
            this.circleElement.setAttribute("fill-opacity", this.options.fillOpacity);
            this.circleElement.setAttribute("stroke-opacity", this.options.strokeOpacity);
            this.circleElement.setAttribute("style", "fill:" + this.options.fillColor + ";stroke:" + this.options.strokeColor + ";stroke-width:" + this.options.strokeWidth + ";position: absolute;");
            this.domPosition((K - this.padding - O), (Q - this.padding - O), this.container);
            return this.container
        },
        renderVML: function (S, Q, N) {
            if (!this.container) {
                this.container = D.crEl("div");
                this.container.id = ("deCarta-circle-container-" + Math.random()).replace(".", "");
                this.container.style.zIndex = this.zIndex;
                this.container.style.position = "absolute";
                return this.container
            }
            var M = D.Window.getViewport();
            var O = this.getPixelRadius(N);
            if (S + O < 0 || Q + O < 0 || S - O > M.width || Q - O > M.height) {
                return false
            }
            var L = Math.round((O * 2) + (this.padding * 2));
            var J = Math.round((O * 2) + (this.padding * 2));
            this.container.style.width = L + "px";
            this.container.style.height = J + "px";
            var P = '<v:fill opacity="' + Math.round(this.options.fillOpacity * 100) + '%" color="' + this.options.fillColor + '"/>';
            var R = '<v:stroke opacity="' + Math.round(this.options.strokeOpacity * 100) + '%" weight="' + this.options.strokeWidth + 'px" color="' + this.options.strokeColor + '" />';
            var K = '<v:oval style="position: relative;top:0;left:0;width:' + L + "px;height:" + J + 'px"> ' + P + R + "</v:oval>";
            this.container.innerHTML = K;
            this.domPosition((S - this.padding - O), (Q - this.padding - O), this.container);
            return this.container
        }
    };
    D.Core.Circle.prototype = D.Utilities.inherit(D.Core.Circle.prototype, D.Core.Shape.prototype);
    D.Core.Position = function (K, L) {
        this.lat = 0;
        this.lon = 0;
        if (K != null) {
            if (arguments.length == 1) {
                if (typeof K == "string") {
                    var J = K.split(",");
                    if (J.length < 2) {
                        J = K.split(" ")
                    }
                    this.lat = parseFloat(J[0]);
                    this.lon = parseFloat(J[1])
                } else {
                    if (typeof K == "object" && K.getLat) {
                        this.lat = K.getLat();
                        this.lon = K.getLon()
                    } else {
                        D.Core.Exception.raise("Unknown parameter format for Position object")
                    }
                }
            } else {
                if (arguments.length == 2) {
                    this.lat = K;
                    this.lon = L
                }
            }
        }
        this.xz = [];
        this.yz = [];
        this.xz[21] = D.Utilities.lon2pix(this.lon, 21);
        this.yz[21] = D.Utilities.lat2pix(this.lat, 21)
    };
    D.Core.Position.prototype = {
        clone: function () {
            return new D.Core.Position(this.lat, this.lon)
        },
        equals: function (J) {
            return (this.lat === J.lat && this.lon === J.lon)
        },
        getLat: function () {
            return parseFloat(this.lat)
        },
        getLon: function () {
            return parseFloat(this.lon)
        },
        getX: function (J) {
            if (J == Math.round(J)) {
                if (!this.xz[J]) {
                    this.xz[J] = D.Utilities.lon2pix(this.lon, J)
                }
                return this.xz[J]
            } else {
                return this.xz[21] * Math.pow(2, J - 21)
            }
        },
        getY: function (J) {
            if (J == Math.round(J)) {
                if (!this.yz[J]) {
                    this.yz[J] = D.Utilities.lat2pix(this.lat, J)
                }
                return this.yz[J]
            } else {
                return this.yz[21] * Math.pow(2, J - 21)
            }
        },
        setXY: function (J, L, K) {
            if (!K) {
                K = 21
            }
            this.lat = D.Utilities.pix2lat(L, K);
            this.lon = D.Utilities.pix2lon(J, K);
            if (this.lon < -180) {
                this.lon = this.lon + 360
            }
            if (this.lon > 180) {
                this.lon = this.lon - 360
            }
            this.yz = [];
            this.xz = [];
            this.xz[21] = D.Utilities.lon2pix(this.lon, 21);
            this.yz[21] = D.Utilities.lat2pix(this.lat, 21)
        },
        getPixelPoint: function (J) {
            if (!J) {
                J = 21
            }
            return {
                x: this.getX(J),
                y: this.getY(J)
            }
        },
        toString: function (J) {
            if (J) {
                return this.lat.toFixed(J) + " " + this.lon.toFixed(J)
            }
            return this.lat + " " + this.lon
        },
        getTileAtZoom: function (K) {
            var J = this.getX(K);
            var O = this.getY(K);
            var M = D.Utilities.tileSizeForZoom(K);
            var L = Math.floor(J / M);
            var N = Math.floor(O / M);
            return {
                N: N,
                E: L
            }
        },
        quantize: function (J) {
            this.setXY(Math.round(this.getX(J)), Math.round(this.getY(J)), J)
        },
        toGeoHash: function (K) {
            var J = (K) ? Math.round((K * 2) / 5) : null;
            return D.Core.GeoHash.encode(this.lat, this.lon, J)
        },
        fromGeoHash: function (K) {
            var J = D.Core.GeoHash.decode(K);
            this.lat = J.lat;
            this.lon = J.lon;
            this.xz = [];
            this.yz = [];
            this.xz[21] = D.Utilities.lon2pix(this.lon, 21);
            this.yz[21] = D.Utilities.lat2pix(this.lat, 21)
        },
        toJSON: function () {
            return this.lat + ", " + this.lon
        }
    };
    D.Core.Constants = {
        _ll_LUT: {
            "EPSG:3395": ["89.787438015348100000,360.00000000000000000", "85.084059050110410000,180.00000000000000000", "66.653475896509040000,90.000000000000000000", "41.170427238429790000,45.000000000000000000", "22.076741328793200000,22.500000000000000000", "11.251819676168665000,11.250000000000000000", "5.653589942659626000,5.625000000000000000", "2.830287664051185000,2.812500000000000000", "1.415581451872543800,1.406250000000000000", "0.707845460801532700,0.703125000000000000", "0.353929573271679340,0.351562500000000000", "0.176965641673330230,0.175781250000000000", "0.088482927761462040,0.087890625000000000", "0.044241477246363230,0.043945312500000000", "0.022120740293895182,0.021972656250000000", "0.011060370355776452,0.010986328125000000", "0.005530185203987857,0.005493164062500000", "0.002765092605263539,0.002746582031250000", "0.001382546303032519,0.001373291015625000", "0.000691272945568983,0.000686645507812500", "0.000345636472797214,0.000343322753906250"],
            "EPSG:3857": ["85.000000000000000000,180.000000000000000000", "85.051128779806600000,180.000000000000000000", "66.513260443111850000,90.000000000000000000", "40.979898069620130000,45.000000000000000000", "21.943045533438180000,22.500000000000000000", "11.178401873711785000,11.250000000000000000", "5.615985819155340000,5.625000000000000000", "2.811371193331140300,2.812500000000000000", "1.406108835435159400,1.406250000000000000", "0.703107352436490900,0.703125000000000000", "0.351560293992270900,0.351562500000000000", "0.175780974247085330,0.175781250000000000", "0.087890590530824220,0.087890625000000000", "0.043945308191358085,0.043945312500000000", "0.021972655711432625,0.021972656250000000", "0.010986328057681535,0.010986328125000000", "0.005493164054094371,0.005493164062500000", "0.002746582030202296,0.002746582031250000", "0.001373291015495537,0.001373291015625000", "0.000686645507798657,0.000686645507812500", "0.000343322753905690,0.000343322753906250"]
        },
        TILE_SIZE: 256
    };
    D.Core.Exception = {
        raise: function B(L) {
            var J = this.getFunctionName(arguments.callee.caller);
            var K = "[" + J + "] - " + L;
            if (D.Core.Configuration.vocalExceptions) {
                alert("Exception: " + K)
            }
            throw (K)
        },
        getFunctionName: function E(L) {
            if (L.name) {
                return L.name
            }
            var K = L.toString();
            var J = K.substring(K.indexOf("function") + 8, K.indexOf("("));
            if (J.replace(/ /g, "")) {
                return J.replace(/ /g, "")
            }
            return "anonymous"
        }
    };
    D.Core.Radius = function (K, J) {
        this.distance = K;
        this.uom = J
    };
    D.Core.Radius.prototype.toString = function () {
        return this.distance + " " + this.uom
    };
    D.Core.Radius.prototype.localize = function (J) {
        if (!J) {
            D.Core.Exception.raise("Locale is required to localize.")
        }
        if (J.country == "US" || J.country == "UK") {
            this.toImperial()
        } else {
            this.toMetric()
        }
        return this
    };
    D.Core.Radius.prototype.toLocalizedString = function (J) {
        return new D.Core.Radius(this.distance, this.uom).localize(J).toString()
    };
    D.Core.Radius.prototype.autoFormat = function () {
        switch (this.uom) {
            case "KM":
                if (this.distance <= 0.5) {
                    this.distance = this.distance.toFixed(1);
                    this.uom = "KM"
                } else {
                    this.distance = (this.distance * 1000).toFixed(0);
                    this.uom = "M"
                }
                break;
            case "M":
                if (this.distance > 500) {
                    this.distance = (this.distance / 1000).toFixed(1);
                    this.uom = "KM"
                } else {
                    this.distance = this.distance.toFixed(0);
                    this.uom = "M"
                }
                break;
            case "MI":
                if (this.distance < 0.3) {
                    this.distance = (1760 * this.distance).toFixed(0);
                    this.uom = "YDS"
                } else {
                    this.distance = this.distance.toFixed(1);
                    this.uom = "MI"
                }
                break;
            case "FT":
                if (this.distance > 300) {
                    if (this.distance > 1500) {
                        this.distance = (this.distance * 0.000189393939).toFixed(1);
                        this.uom = "MI"
                    } else {
                        this.distance = (0.333333333 * this.distance).toFixed(0);
                        this.uom = "YDS"
                    }
                } else {
                    this.distance = this.distance.toFixed(0);
                    this.uom = "FT"
                }
                break
        }
        return this
    };
    D.Core.Radius.prototype.getZoom = function (O, K, N) {
        var L = this.getDegrees();
        var M = new D.Core.Position(O.lat - L, O.lon - L);
        var J = new D.Core.Position(O.lat + L, O.lon + L);
        return new D.Core.BoundingBox([M, J]).getIdealCenterAndZoom(K, N).zoom
    };
    D.Core.Radius.prototype.getDegrees = function () {
        if (this.uom == "KM") {
            return this.distance / 111.111
        } else {
            if (this.uom == "M") {
                return (this.distance / 1000) / 111.111
            } else {
                if (this.uom == "MI") {
                    return (this.distance * 1.609) / 111.111
                } else {
                    if (this.uom == "FT") {
                        return ((this.distance / 3.28) / 1000) / 111.111
                    }
                }
            }
        }
        return 0
    };
    D.Core.Radius.prototype.toMetric = function () {
        if (this.uom == "KM" || this.uom == "M") {
            return
        }
        if (this.uom == "MI") {
            this.distance *= 1.609344;
            this.uom = "KM"
        }
        if (this.uom == "FT") {
            this.distance *= 0.3048;
            this.uom = "M"
        }
        return this
    };
    D.Core.Radius.prototype.toImperial = function () {
        if (this.uom == "MI" || this.uom == "FT") {
            return
        }
        if (this.uom == "KM") {
            this.distance *= 0.621371192;
            this.uom = "MI"
        }
        if (this.uom == "M") {
            this.distance *= 3.2808399;
            this.uom = "FT"
        }
        return this
    };
    D.Core.Radius.prototype.getMiles = function () {
        switch (this.uom) {
            case "KM":
                return this.distance * 0.621371192;
                break;
            case "M":
                return (this.distance / 1000) * 0.621371192;
                break;
            case "MI":
                return this.distance;
                break;
            case "FT":
                return this.distance * 0.000189393939;
                break;
            default:
                D.Core.Exception.raise("Unknown UOM : " + this.uom);
                break
        }
    };
    D.Core.Radius.prototype.getKm = function () {
        switch (this.uom) {
            case "KM":
                return this.distance;
                break;
            case "M":
                return (this.distance / 1000);
                break;
            case "MI":
                return this.distance * 1.609344;
                break;
            case "FT":
                return this.distance * 0.0003048;
                break;
            default:
                D.Core.Exception.raise("Unknown UOM : " + this.uom);
                break
        }
    };
    D.Core.Distance = D.Core.Radius;
    D.Core.Locale = function (K, J) {
        this.language = K.toUpperCase();
        this.country = J.toUpperCase()
    };
    D.Core.Locale.prototype = {
        getLanguage: function () {
            return this.language
        },
        setLanguage: function (J) {
            this.language = J.toUpperCase()
        },
        getCountry: function () {
            return this.country
        },
        setCountry: function (J) {
            this.country = J.toUpperCase()
        },
        toString: function () {
            return this.language + "_" + this.country
        }
    };
    G.encodeURIComponentUTF8 = function (T) {
        T = T + "";
        var O = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_.~";
        var M = "!*'();:@&=+$,/?%#[]";
        var Q = O + M;
        var R = "0123456789ABCDEFabcdef";

        function P(J) {
            return "%" + R.charAt(J >> 4) + R.charAt(J & 15)
        }
        var L = "";
        for (var U = 0; U < T.length; U++) {
            var N = T.charAt(U);
            if (O.indexOf(N) != -1) {
                L = L + N
            } else {
                var S = T.charCodeAt(U);
                if (S < 128) {
                    L = L + P(S)
                }
                if (S > 127 && S < 2048) {
                    L = L + P((S >> 6) | 192);
                    L = L + P((S & 63) | 128)
                }
                if (S > 2047 && S < 65536) {
                    L = L + P((S >> 12) | 224);
                    L = L + P(((S >> 6) & 63) | 128);
                    L = L + P((S & 63) | 128)
                }
                if (S > 65535) {
                    L = L + P((S >> 18) | 240);
                    L = L + P(((S >> 12) & 63) | 128);
                    L = L + P(((S >> 6) & 63) | 128);
                    L = L + P((S & 63) | 128)
                }
            }
        }
        return L
    };
    D.Core.JSRequest = {
        callbacks: {},
        timeouts: {},
        interceptors: {
            DirectoryResponse: [],
            RUOKResponse: [],
            DetermineRouteResponse: [],
            ReverseGeocodeResponse: [],
            GeocodeResponse: []
        },
        sessionId: Math.ceil((new Date().getTime()) * Math.random()),
        requestId: null,
        init: function (K) {
            if (typeof K !== "function") {
                D.Core.Exception.raise("JSRequest.init needs a callback parameter")
            }
            var L = "       <xls:Request version='1.0' requestID='1675192' methodName='RuokRequest'>             <xls:RUOKRequest />       </xls:Request>";
            var M = new Date().getTime();
            var J = D.Core.Configuration.url.split(":")[0];
            this.send(L, function (R) {
                var T = (new Date().getTime()) - M;
                try {
                    if (typeof R.XLS.ResponseHeader.ErrorList === "object") {
                        K({
                            success: false,
                            msg: R.XLS.ResponseHeader.ErrorList.Error.message,
                            exTime: T
                        })
                    } else {
                        if (typeof R.XLS.Response.RUOKResponse === "object") {
                            if (R.XLS.Response.RUOKResponse.urlFormats) {
                                if (D.Core.Configuration.urlVersion == null || D.Core.Configuration.urlVersion == "auto") {
                                    var N = R.XLS.Response.RUOKResponse.urlFormats.split("|");
                                    var U = 1;
                                    for (var Q = 0; Q < N.length; Q++) {
                                        U = Math.max(U, parseFloat(N[Q].match(/\d/g)))
                                    }
                                    D.Core.Configuration.urlVersion = U
                                }
                            }
                            D.Core.Configuration.url = J + "://" + R.XLS.Response.RUOKResponse.hostName + "/openls/JSON";
                            var P = R.XLS.Response.RUOKResponse.maxHostAliases ? parseInt(R.XLS.Response.RUOKResponse.maxHostAliases) : 0;
                            D.Core.Configuration.streetTileHosts = [];
                            if (P) {
                                for (var Q = 1; Q <= P; Q++) {
                                    var O = J + "://" + R.XLS.Response.RUOKResponse.hostName.replace(/\./, "-0" + Q + ".");
                                    D.Core.Configuration.streetTileHosts.push(O)
                                }
                            } else {
                                D.Core.Configuration.streetTileHosts.push("http://" + R.XLS.Response.RUOKResponse.hostName)
                            }
                            K({
                                success: true,
                                msg: "ok",
                                exTime: T
                            })
                        }
                    }
                } catch (S) {
                    K({
                        success: false,
                        msg: S.message,
                        exTime: T
                    })
                }
            }.bind(this), function () {
                var N = (new Date().getTime()) - M;
                K({
                    success: false,
                    msg: "connection timeout",
                    exTime: N
                })
            }.bind(this))
        },
        send: function (O, R, L, P) {
            var Q = Math.ceil((new Date().getTime()) * Math.random());
            var M = "deCarta-mob-req-" + Q;
            var S = /requestID=[\'\"]([0-9]+)[\'\"]/;
            O = O.replace(S, 'requestID="' + Q + '"');
            if (D.Core.Configuration.consolelogXML) {
                console.log(this.getRequestHeader() + O + this.getRequestFooter())
            }
            var N = encodeURIComponentUTF8(this.getRequestHeader() + O + this.getRequestFooter());
            this.callbacks[Q] = function (T) {
                if (D.Core.Configuration.consolelogXML) {
                    try {
                        console.log(T)
                    } catch (X) {}
                }
                var W = D.geId(M);
                clearTimeout(this.timeouts[Q]);
                if (!P) {
                    for (var V in T.response.XLS.Response) {
                        if (this.interceptors[V]) {
                            for (var U = 0; U < this.interceptors[V].length; U++) {
                                if (typeof this.interceptors[V][U] === "function") {
                                    T.response = this.interceptors[V][U](T.response)
                                }
                            }
                        }
                    }
                }
                if (W) {
                    W.parentNode.removeChild(W);
                    R(T.response)
                }
            }.bind(this);
            this.timeouts[Q] = setTimeout(function (T) {
                this.cancel(T);
                if (typeof L == "function") {
                    L({
                        err: "timeout"
                    })
                }
            }.bind(this, M, L), D.Core.Configuration.requestTimeout);
            var K = D.Core.Configuration.url + "?reqID=" + Q + "&chunkNo=1&numChunks=1&callback=window.deCarta.Core.JSRequest.callbacks[" + Q + "]&data=" + N + "&responseFormat=JSON";
            var J = D.crEl("script");
            J.id = M;
            J.src = K;
            H.body.appendChild(J);
            return M
        },
        getRequestHeader: function () {
            var J = '<?xml version="1.0"?><xls:XLS version="1" xls:lang="en" xmlns:xls="http://www.opengis.net/xls" rel="' + D.Core.Configuration.apiVersion + '" xmlns:gml="http://www.opengis.net/gml"><xls:RequestHeader clientName="' + D.Core.Configuration.clientName + '" sessionID="' + this.sessionId + '" clientAPI="mobilejs" clientPassword="' + D.Core.Configuration.clientPassword + '" configuration="' + D.Core.Configuration.defaultConfig + '"/>';
            return J
        },
        getRequestFooter: function () {
            var J = "</xls:XLS>";
            return J
        },
        cancel: function (J) {
            if (D.geId(J)) {
                var K = D.geId(J);
                K.src = null;
                K.parentNode.removeChild(K);
                return true
            } else {
                return false
            }
        },
        addInterceptor: function (J, K) {
            if (!this.interceptors[J]) {
                D.Core.Exception.raise("Interceptor type " + J + " not supported")
            }
            var L = this.interceptors[J].length;
            this.interceptors[J].push(K);
            return J + "-" + L
        },
        removeInterceptor: function (K, L) {
            if (!this.interceptors[K]) {
                D.Core.Exception.raise("Interceptor type " + K + " not supported")
            }
            for (var J = 0; J < this.interceptors[K].length; J++) {
                if (this.interceptors[K][J] == L) {
                    this.interceptors[K][J] = null;
                    return
                }
            }
        },
        removeInterceptorById: function (J) {
            var J = J.split("-");
            this.interceptors[J[0]][J[1]] = null;
            return
        }
    };
    D.Core.POISearch = {
        getXML: function (R) {
            var S = 'database="' + R.database + '"';
            var U = (R.sortDirection) ? 'sortDirection="' + R.sortDirection + '"' : "";
            var P = (R.rankCriteria) ? 'rankCriteria="' + R.rankCriteria + '"' : "";
            var T = "";
            if (R.routeId) {
                R.corridorParams.routeId = R.routeId
            }
            if (R.corridorParams.routeId) {
                T += "<xls:NearRoute>";
                if (R.corridorParams.measure === "distance") {
                    T += "<xls:distance value='" + R.corridorParams.measureValue + "' uom='M'/>"
                } else {
                    if (R.corridorParams.measure === "euclideanDistance") {
                        T += "<xls:euclideanDistance value='" + R.corridorParams.measureValue + "' uom='M'/>"
                    } else {
                        T += "<xls:drivetime>P0DT" + Math.floor(R.corridorParams.measureValue / 60) + "H" + (R.corridorParams.measureValue % 60) + "M0S</xls:drivetime>"
                    }
                }
                T += "<xls:RouteID>" + R.corridorParams.routeId + "</xls:RouteID>";
                T += "</xls:NearRoute>"
            } else {
                T = '<xls:WithinDistance><xls:POI ID="1"><gml:Point><gml:pos>' + R.position.lat + " " + R.position.lon + '</gml:pos></gml:Point></xls:POI><xls:MinimumDistance value="0" uom="KM"/><xls:MaximumDistance value="' + R.radius.distance + '" uom="' + R.radius.uom + '"/></xls:WithinDistance>'
            }
            var Q = "<xls:Request maximumResponses='" + R.maximumResponses + '\' version="1.0" requestID="0123456" methodName="DirectoryRequest"><xls:DirectoryRequest ' + S + " " + U + " " + P + "><xls:POILocation>" + T + "</xls:POILocation><xls:POIProperties>";
            var J = "</xls:POIProperties></xls:DirectoryRequest></xls:Request>";
            var O = "";
            var M = D.Utilities.makeArrayFix(R.properties);
            for (var N = 0; N < M.length; N++) {
                for (var L in M[N]) {
                    if (typeof M[N][L] == "object") {
                        var V = " ";
                        for (var K in M[N][L]) {
                            V += K + '="' + M[N][L][K] + '" '
                        }
                        O += Q + '<xls:POIProperty name="' + L + '" ' + V + " />" + J
                    } else {
                        O += Q + '<xls:POIProperty value="' + M[N][L] + '" name="' + L + '"/>' + J
                    }
                }
            }
            return O
        },
        execute: function (M, L, J) {
            var K = new D.Core.SearchCriteria();
            M = D.Utilities.extendObject(K, M);
            if (!L) {
                D.Core.Exception.raise("You need to provide a search callback, or you will never know what was found")
            }
            if (M.map) {
                M.position = M.map.getCenter();
                if (!M.radiusOverride) {
                    M.radius = M.map.getRadius()
                }
            }
            if (!(M.position || M.corridorParams.routeId)) {
                D.Core.Exception.raise("A position or routeId is required to search. Please provide one in the search criteria")
            }
            return D.Core.JSRequest.send(this.getXML(M), this.handleResponse.bind(this, L), this.handleFailure.bind(this, L), J)
        },
        handleResponse: function (P, K) {
            var J;
            try {
                if (D.Utilities.isArray(K)) {
                    P(K);
                    return
                }
                if (D.Utilities.isArray(K.XLS.Response)) {
                    var M = [];
                    for (var L = 0; L < K.XLS.Response.length; L++) {
                        J = K.XLS.Response[L].DirectoryResponse.POIContext;
                        if (J) {
                            var O = D.Utilities.makeArrayFix(J);
                            M = M.concat(O)
                        }
                    }
                    P(M)
                } else {
                    J = K.XLS.Response.DirectoryResponse.POIContext;
                    if (J) {
                        P(D.Utilities.makeArrayFix(K.XLS.Response.DirectoryResponse.POIContext))
                    } else {
                        P([])
                    }
                }
                P(K)
            } catch (N) {
                P([], {
                    message: N.message,
                    param: K
                })
            }
        },
        handleFailure: function (K, J) {
            K([], {
                param: J,
                message: "Error executing search"
            })
        },
        responseInterceptor: function (L) {
            var N = [];
            if (D.Utilities.isArray(L.XLS.Response)) {
                for (var P = 0; P < L.XLS.Response.length; P++) {
                    poiContextObject = L.XLS.Response[P].DirectoryResponse.POIContext;
                    if (poiContextObject) {
                        var U = D.Utilities.makeArrayFix(poiContextObject);
                        N = N.concat(U)
                    }
                }
            } else {
                poiContextObject = L.XLS.Response.DirectoryResponse.POIContext;
                if (poiContextObject) {
                    N = D.Utilities.makeArrayFix(L.XLS.Response.DirectoryResponse.POIContext)
                } else {
                    N = []
                }
            }
            var Q = [];
            for (var P = 0; P < N.length; P++) {
                var O = {};
                var K = N[P];
                O.ID = K.POI.ID;
                O.name = K.POI.POIName;
                O.position = new D.Core.Position(K.POI.Point.pos);
                O.address = {};
                O.phoneNumber = K.POI.phoneNumber;
                if (K.Distance) {
                    if (K.Distance.length) {
                        O.distance = {
                            onRoute: new D.Core.Distance(K.Distance[0].value, K.Distance[0].uom),
                            offRoute: new D.Core.Distance(K.Distance[1].value, K.Distance[1].uom)
                        }
                    } else {
                        O.distance = new D.Core.Distance(K.Distance.value, K.Distance.uom)
                    }
                } else {
                    if (K.Duration) {
                        O.duration = {
                            onRoute: {
                                time: K.Duration[0].content
                            },
                            offRoute: {
                                time: K.Duration[1].content
                            }
                        }
                    }
                }
                var S = new D.Core.StructuredAddress();
                S.fromWSResponse(K.POI.Address);
                O.address = S;
                for (var M = 0; M < K.POI.POIAttributeList.POIInfoList.POIInfo.length; M++) {
                    var J = K.POI.POIAttributeList.POIInfoList.POIInfo[M].name;
                    var T = K.POI.POIAttributeList.POIInfoList.POIInfo[M].value;
                    var R = J.split("-");
                    if (R[0] == "category") {
                        if (!O.categories) {
                            O.categories = []
                        }
                        if (O.categories.indexOf(T.toLowerCase())) {
                            O.categories.push(T.toLowerCase())
                        }
                    }
                }
                Q.push(O)
            }
            return Q
        }
    };
    D.Core.JSRequest.addInterceptor("DirectoryResponse", D.Core.POISearch.responseInterceptor);
    D.Core.Geocoder = {
        getGeocodeXML: function (J) {
            if (J.type == "freeForm") {
                var K = '      <xls:Request maximumResponses="10" version="1.0" requestID="9132342" methodName="GeocodeRequest">            <xls:GeocodeRequest returnFreeForm="false">' + J.toXML() + "            </xls:GeocodeRequest>      </xls:Request>"
            } else {
                var K = "      <xls:Request maximumResponses='10' version='1.0' requestID='4387206' methodName='GeocodeRequest'>            <xls:GeocodeRequest returnFreeForm='false'>                  <xls:Address countryCode='" + J.locale.country + "' language='" + J.locale.language + "'>";
                if (J.buildingNumber || J.street) {
                    K += "           <xls:StreetAddress>                              <xls:Building number='" + J.buildingNumber + "'/>                              <xls:Street>" + J.street + "</xls:Street>                        </xls:StreetAddress>"
                }
                if (J.municipality) {
                    K += "                        <xls:Place type='Municipality'>" + J.municipality + "</xls:Place>"
                }
                if (J.municipalitySubdivision) {
                    K += "                        <xls:Place type='MunicipalitySubdivision'>" + J.municipalitySubdivision + "</xls:Place>"
                }
                if (J.countrySubdivision) {
                    K += "                        <xls:Place type='CountrySubdivision'>" + J.countrySubdivision + "</xls:Place>"
                }
                if (J.countrySecondarySubdivision) {
                    K += "                        <xls:Place type='CountrySecondarySubdivision'>" + J.countrySecondarySubdivision + "</xls:Place>"
                }
                if (J.countryTertiarySubdivision) {
                    K += "                        <xls:Place type='CountryTertiarySubdivision'>" + J.countryTertiarySubdivision + "</xls:Place>"
                }
                if (J.postalCode) {
                    K += "                        <xls:PostalCode>" + J.postalCode + "</xls:PostalCode>"
                }
                K += "                  </xls:Address>            </xls:GeocodeRequest>      </xls:Request>"
            }
            return K
        },
        getRevGeocodeXML: function (L, K) {
            K = K || "StreetAddress";
            var J = "<xls:Request maximumResponses='10' version='1.0' requestID='0123456789' methodName='ReverseGeocodeRequest'><xls:ReverseGeocodeRequest><xls:Position><gml:Point><gml:pos>" + L.getLat() + " " + L.getLon() + "</gml:pos></gml:Point></xls:Position><xls:ReverseGeocodePreference>" + K + "</xls:ReverseGeocodePreference></xls:ReverseGeocodeRequest></xls:Request>";
            return J
        },
        geocode: function (J, K) {
            if (!J.type || !(J.type in {
                freeForm: true,
                structured: true
            })) {
                D.Core.Exception.raise("When using the geocode function, the first parameter must be an address object")
            }
            if (typeof K !== "function") {
                D.Core.Exception.raise("When using the geocode function, the second parameter must be a callback function")
            }
            D.Core.JSRequest.send(this.getGeocodeXML(J), this.handleResponse.bind(this, K), this.handleFailure.bind(this, K))
        },
        reverseGeocode: function (J, L, K) {
            if (typeof L !== "function") {
                D.Core.Exception.raise("When using the reverseGeocode function, the second parameter must be a callback function")
            }
            D.Core.JSRequest.send(this.getRevGeocodeXML(J, K), this.handleRevResponse.bind(this, L), this.handleFailure.bind(this, L))
        },
        handleRevResponse: function (N, J) {
            try {
                var L = J.XLS.Response.ReverseGeocodeResponse.ReverseGeocodedLocation;
                var K = {};
                K.Address = new D.Core.StructuredAddress();
                K.Address.fromWSResponse(L.Address);
                K.Position = new D.Core.Position(L.Point.pos);
                if (L.SearchCentreDistance) {
                    K.searchCenterDistance = new D.Core.Distance(L.SearchCentreDistance.value, L.SearchCentreDistance.uom)
                }
                N(K, L)
            } catch (M) {
                N({
                    Address: {},
                    Position: {}
                }, null)
            }
        },
        handleResponse: function (P, J) {
            var M = "Unknown";
            try {
                if (J.XLS.Response.ErrorList.Error.message) {
                    P({
                        error: J.XLS.Response.ErrorList.Error.message
                    });
                    return
                }
            } catch (O) {}
            try {
                var L = D.Utilities.makeArrayFix(J.XLS.Response.GeocodeResponse.GeocodeResponseList.GeocodedAddress);
                for (var K = 0; K < L.length; K++) {
                    var N = new D.Core.StructuredAddress();
                    N.fromWSResponse(L[K].Address);
                    L[K].Address = N;
                    L[K].Position = new D.Core.Position(L[K].Point.pos);
                    L[K].Point = null;
                    L[K].matchType = L[K].GeocodeMatchCode.matchType;
                    L[K].accuracy = L[K].GeocodeMatchCode.accuracy;
                    L[K].GeocodeMatchCode = null;
                    delete L[K].GeocodeMatchCode;
                    delete L[K].Point
                }
                P(L, J)
            } catch (O) {
                try {
                    M = J.XLS.Response.ErrorList.Error.message
                } catch (O) {}
                D.Core.Exception.raise("Error handling response : " + M)
            }
        },
        handleFailure: function () {}
    };
    D.Core.Routing = {
        getXML: function (R) {
            var O = (R.alternateRoutes) ? ' numAltRoutes="' + R.alternateRoutes + '" ' : "";
            var Q = "<xls:Request maximumResponses='10' version='1.0' requestID='0123456789' methodName='DetermineRouteRequest'><xls:DetermineRouteRequest " + O + " distanceUnit='" + R.distanceUnit + "' routeQueryType='" + R.routeQueryType + "' provideRouteHandle='" + R.provideRouteHandle + "'>";
            "<xls:RoutePlan";
            var U = "<xls:RoutePlan";
            if (R.trafficEnabled == "true") {
                U += " useRealTimeTraffic='true'"
            }
            if (R.optimized) {
                U += " optimize='true' "
            }
            U += ">";
            var K = "<xls:RoutePreference>" + R.routePreference + "</xls:RoutePreference>";
            var P = "";
            var J = R.waypoints.shift();
            var L = R.waypoints.pop();
            P = "<xls:WayPointList><xls:StartPoint><xls:Position><gml:Point><gml:pos>" + J.getLat() + " " + J.getLon() + "</gml:pos></gml:Point></xls:Position></xls:StartPoint>";
            for (var M = 0; M < R.waypoints.length; M++) {
                var T = R.waypoints[M];
                P += "<xls:ViaPoint><xls:Position><gml:Point><gml:pos>" + T.getLat() + " " + T.getLon() + "</gml:pos></gml:Point></xls:Position></xls:ViaPoint>"
            }
            P += "<xls:EndPoint><xls:Position><gml:Point><gml:pos>" + L.getLat() + " " + L.getLon() + "</gml:pos></gml:Point></xls:Position></xls:EndPoint></xls:WayPointList>";
            R.waypoints.push(L);
            R.waypoints.unshift(J);
            var N = "";
            if (R.avoidList.length > 0 || R.avoidAreas.length > 0) {
                N += "<xls:AvoidList>";
                for (M = 0; M < R.avoidAreas.length; M++) {
                    N += this.avoidAreaXML(R.avoidAreas[M])
                }
                for (M = 0; M < R.avoidList.length; M++) {
                    N += "<xls:AvoidFeature>" + R.avoidList[M].toString() + "</xls:AvoidFeature>"
                }
                N += "</xls:AvoidList>"
            }
            var S = "</xls:RoutePlan><xls:RouteInstructionsRequest providePoint='true' rules='" + R.instructionRules + "'/><xls:RouteGeometryRequest returnRouteIDOnly='false'/></xls:DetermineRouteRequest></xls:Request>";
            return Q + U + K + P + N + S
        },
        avoidAreaXML: function (K) {
            var L;
            var J = "<xls:AOI>";
            J += K.getGML();
            J += "</xls:AOI>";
            return J
        },
        execute: function (L, K) {
            if (!L.waypoints || L.waypoints.length < 2) {
                D.Core.Exception.raise("At least two waypoints are required for routing. criteria.waypoints is not a valid array, or does not contain 2 waypoints.")
            }
            var J = new D.Core.RouteCriteria();
            L = D.Utilities.extendObject(J, L);
            D.Core.JSRequest.send(this.getXML(L), this.handleResponse.bind(this, K), this.handleFailure.bind(this, K))
        },
        handleResponse: function (L, J) {
            try {
                L(J)
            } catch (K) {
                L({}, {
                    message: "Error executing routing request: " + K.message
                })
            }
        },
        handleFailure: function (J) {
            J({}, {
                message: "Error executing routing request."
            })
        },
        responseInterceptor: function (K) {
            function J(N) {
                var O = {};
                O.routeGeometry = [];
                for (var P = 0; P < N.RouteGeometry.LineString.pos.length; P++) {
                    O.routeGeometry.push(new D.Core.Position(N.RouteGeometry.LineString.pos[P]))
                }
                if (N.RouteHandle) {
                    O.routeID = N.RouteHandle.routeID
                }
                O.routeInstructions = {
                    list: N.RouteInstructionsList.RouteInstruction,
                    language: N.RouteInstructionsList.lang
                };
                for (var P = 0; P < O.routeInstructions.list.length; P++) {
                    O.routeInstructions.list[P].Point = new D.Core.Position(O.routeInstructions.list[P].Point);
                    O.routeInstructions.list[P].distance = new D.Core.Distance(O.routeInstructions.list[P].distance.value, O.routeInstructions.list[P].distance.uom || "M")
                }
                O.routeSummary = {
                    boundingBox: new D.Core.BoundingBox([N.RouteSummary.BoundingBox.pos[0].content, N.RouteSummary.BoundingBox.pos[1].content]),
                    totalDistance: new D.Core.Distance(N.RouteSummary.TotalDistance.value, N.RouteSummary.TotalDistance.uom),
                    totalTime: N.RouteSummary.TotalTime
                };
                return O
            }
            K = K.XLS.Response.DetermineRouteResponse;
            ret = J(K);
            if (K.AlternateRoute) {
                if (!K.AlternateRoute.length) {
                    K.AlternateRoute = [K.AlternateRoute]
                }
                for (var L = 0; L < K.AlternateRoute.length; L++) {
                    var M = J(K.AlternateRoute[L]);
                    if (!ret.alternates) {
                        ret.alternates = []
                    }
                    ret.alternates.push(M)
                }
            }
            delete K;
            return ret
        }
    };
    D.Core.JSRequest.addInterceptor("DetermineRouteResponse", D.Core.Routing.responseInterceptor);
    D.Core.StructuredAddress = function (K, J) {
        if (!K) {
            K = {}
        }
        this.locale = J || new D.Core.Locale("en", "US");
        if (K.buildingNumber || K.buildingNumber == 0) {
            this.buildingNumber = K.buildingNumber
        } else {
            this.buildingNumber = ""
        }
        this.landmark = "";
        this.street = K.street || "";
        this.streetNameAndNumber = "";
        this.speedLimit = "";
        this.countryCode = "";
        this.countrySubdivision = K.countrySubdivision || "";
        this.countrySecondarySubdivision = K.countrySecondarySubdivision || "";
        this.countryTertiarySubdivision = "";
        this.municipality = K.municipality || "";
        this.postalCode = K.postalCode || "";
        this.municipalitySubdivision = K.municipalitySubdivision || "";
        this.type = "structured"
    };
    D.Core.StructuredAddress.prototype = {
        toString: function () {
            var J = "";
            if (this.buildingNumber != "" && typeof this.buildingNumber != "object") {
                J += this.buildingNumber + " "
            }
            if (this.street != "" && typeof this.street === "string") {
                J += this.street + " "
            }
            if ((D.Core.Configuration.country === "CH") && this.municipalitySubdivision != "" && typeof this.municipalitySubdivision === "string") {
                J += this.municipalitySubdivision + " "
            }
            if (this.municipality != "" && typeof this.municipality === "string") {
                J += this.municipality + " "
            } else {
                if (this.municipalitySubdivision != "" && typeof this.municipalitySubdivision === "string") {
                    J += this.municipalitySubdivision + " "
                }
            }
            if (this.countrySubdivision != "" && typeof this.countrySubdivision === "string") {
                J += this.countrySubdivision + " "
            }
            if (this.postalCode != "" && typeof this.postalCode === "string") {
                J += this.postalCode
            }
            return J
        },
        fromWSResponse: function (K) {
            if (K.StreetAddress) {
                if (K.StreetAddress.Building) {
                    if (K.StreetAddress.Building.number.length && K.StreetAddress.Building.number.indexOf("-") > -1) {
                        var L = K.StreetAddress.Building.number.split(" ");
                        K.StreetAddress.Building.number = L[0] + "-" + L[L.length - 1]
                    }
                    this.buildingNumber = K.StreetAddress.Building.number
                }
                if (K.StreetAddress.Street) {
                    this.street = K.StreetAddress.Street
                }
            }
            if (K.freeFormAddress) {
                this.freeFormAddress = K.freeFormAddress
            }
            if (K.countryCode) {
                this.locale.country = K.countryCode;
                this.countryCode = K.countryCode
            }
            if (K.language) {
                this.locale.language = K.language
            }
            if (K.Place) {
                K.Place = D.Utilities.makeArrayFix(K.Place);
                for (var J = 0; J < K.Place.length; J++) {
                    var M = K.Place[J].type.substring(0, 1).toLowerCase() + K.Place[J].type.substring(1);
                    this[M] = K.Place[J].content
                }
            }
            if (K.StreetIntersection) {
                this.streetIntersection = K.StreetIntersection
            }
        },
        fromWSAddressResponse: function (J) {
            for (var K in this) {
                if (this.hasOwnProperty(K) && J[K]) {
                    this[K] = J[K]
                }
            }
        },
        toXML: function () {},
        toFreeForm: function () {
            return new D.Core.FreeFormAddress(this.toString(), new D.Core.Locale("EN", "US"))
        }
    };
    D.Core.FreeFormAddress = function (K, J) {
        this.address = K;
        this.locale = J;
        this.type = "freeForm"
    };
    D.Core.FreeFormAddress.prototype = {
        toString: function () {
            return this.address
        },
        toXML: function () {
            var J = '<xls:Address countryCode="' + this.locale.getCountry() + '" language="' + this.locale.getLanguage() + '"><xls:freeFormAddress>' + this.address + "</xls:freeFormAddress></xls:Address>";
            return J
        }
    };
    D.Core.SearchCriteria = function () {};
    D.Core.SearchCriteria.prototype = {
        queryString: null,
        maximumResponses: 10,
        database: "search:decarta:poi",
        sortDirection: "Ascending",
        sortCriteria: "Distance",
        rankCriteria: "Score",
        allowAggregates: false,
        retrieveAll: false,
        properties: {},
        position: null,
        radius: new D.Core.Radius(5, "km"),
        corridorParams: {
            routeId: null,
            measure: "distance",
            measureValue: 10
        },
        map: null
    };
    D.Core.RouteCriteria = function () {};
    D.Core.RouteCriteria.prototype = {
        distanceUnit: "M",
        routeQueryType: "RMAN",
        provideRouteHandle: "false",
        routePreference: "Fastest",
        waypoints: [],
        instructionProvidePoint: "true",
        instructionRules: "maneuver-rules",
        returnIdOnly: "false",
        trafficEnabled: "false",
        avoidAreas: [],
        avoidList: [],
        alternateRoutes: 0,
        optimized: false
    };
    D.Core.PositionAnimator = function (J) {
        if (J) {
            this.animate(J)
        }
    };
    D.Core.PositionAnimator.prototype = {
        animate: function (J) {
            var K = {
                start: null,
                end: null,
                duration: 300,
                easing: "linear",
                onStep: null,
                onEnd: null
            };
            if (!J.start || !J.end || !J.onStep) {
                D.Core.Exception.raise("You need to specify a start point, and end point and a callback for a position animation")
            }
            J = D.Utilities.extendObject(K, J);
            this.start = J.start;
            this.end = J.end;
            this.duration = J.duration;
            this.onStep = J.onStep;
            this.onEnd = J.onEnd;
            this.easingX = (J.easingX) ? J.easingX : (J.easing) ? J.easing : "linear";
            this.easingY = (J.easingY) ? J.easingY : (J.easing) ? J.easing : "linear";
            this.easingFnX = D.Easing(this.easingX);
            this.easingFnY = D.Easing(this.easingY);
            this.startTime = new Date().getTime();
            this.endTime = this.startTime + this.duration;
            this.step()
        },
        step: function () {
            if (this.mustStop) {
                return
            }
            var P = new Date().getTime() - this.startTime;
            var M = 1 - ((this.endTime - new Date().getTime()) / this.duration);
            if (M >= 0.99) {
                if (typeof this.onStep === "function") {
                    this.onStep(this.end)
                }
                if (typeof this.onEnd === "function") {
                    this.onEnd(this.end)
                }
            } else {
                var O = this.posToPix(this.start);
                var L = this.posToPix(this.end);
                var K = L.x - O.x;
                var J = L.y - O.y;
                var N = this.pixToPos({
                    x: this.easingFnX(P, O.x, K, this.duration),
                    y: this.easingFnY(P, O.y, J, this.duration)
                });
                if (typeof this.onStep === "function") {
                    this.onStep(N)
                }
                requestAnimFrame(this.step.bind(this))
            }
        },
        stop: function () {
            this.mustStop = true
        },
        posToPix: function (J) {
            return {
                x: D.Utilities.lon2pix(J.getLon(), 21),
                y: D.Utilities.lat2pix(J.getLat(), 21)
            }
        },
        pixToPos: function (J) {
            return new D.Core.Position(D.Utilities.pix2lat(J.y, 21), D.Utilities.pix2lon(J.x, 21))
        }
    };
    D.Core.ZoomAnimator = function (J) {
        if (J) {
            this.animate(J)
        }
    };
    D.Core.ZoomAnimator.prototype = {
        animate: function (J) {
            var K = {
                start: null,
                end: null,
                duration: 300,
                easing: "linear",
                onStep: null,
                onEnd: null
            };
            if (!J.start || !J.end || !J.onStep) {
                D.Core.Exception.raise("You need to specify a start point, and end point and a callback for a position animation")
            }
            this.start = J.start;
            this.end = J.end;
            this.duration = J.duration;
            this.onStep = J.onStep;
            this.onEnd = J.onEnd;
            this.easing = (J.easing) ? J.easing : "linear";
            this.easingFn = D.Easing(this.easing);
            this.startTime = new Date().getTime();
            this.endTime = this.startTime + this.duration;
            this.step()
        },
        step: function () {
            if (this.mustStop) {
                return
            }
            var L = new Date().getTime() - this.startTime;
            var J = 1 - ((this.endTime - new Date().getTime()) / this.duration);
            if (J >= 0.99) {
                if (typeof this.onStep === "function") {
                    this.onStep(this.end)
                }
                if (typeof this.onEnd === "function") {
                    this.onEnd(this.end)
                }
            } else {
                var K = this.easingFn(L, this.start, this.end - this.start, this.duration);
                if (typeof this.onStep === "function") {
                    this.onStep(K)
                }
                requestAnimFrame(this.step.bind(this))
            }
        },
        stop: function () {
            this.mustStop = true
        }
    };
    D.Easing = function (N) {
        var J = Math.PI * 2,
            O = Math.PI / 2;
        var S = Math.abs,
            M = Math.pow,
            P = Math.sin,
            L = Math.asin,
            Q = Math.cos;
        var R = 1.70158;
        var K = {
            linear: function (U, T, W, V) {
                return W * U / V + T
            },
            backin: function (U, T, W, V) {
                return W * (U /= V) * U * ((R + 1) * U - R) + T
            },
            backout: function (U, T, W, V) {
                return W * ((U = U / V - 1) * U * ((R + 1) * U + R) + 1) + T
            },
            backinout: function (U, T, W, V) {
                return ((U /= V / 2) < 1) ? W / 2 * (U * U * (((R *= (1.525)) + 1) * U - R)) + T : W / 2 * ((U -= 2) * U * (((R *= (1.525)) + 1) * U + R) + 2) + T
            },
            bouncein: function (U, T, W, V) {
                return W - K.bounceout(V - U, 0, W, V) + T
            },
            bounceout: function (U, T, W, V) {
                if ((U /= V) < (1 / 2.75)) {
                    return W * (7.5625 * U * U) + T
                } else {
                    if (U < (2 / 2.75)) {
                        return W * (7.5625 * (U -= (1.5 / 2.75)) * U + 0.75) + T
                    } else {
                        if (U < (2.5 / 2.75)) {
                            return W * (7.5625 * (U -= (2.25 / 2.75)) * U + 0.9375) + T
                        } else {
                            return W * (7.5625 * (U -= (2.625 / 2.75)) * U + 0.984375) + T
                        }
                    }
                }
            },
            bounceinout: function (U, T, W, V) {
                if (U < V / 2) {
                    return K.bouncein(U * 2, 0, W, V) / 2 + T
                } else {
                    return K.bounceout(U * 2 - V, 0, W, V) / 2 + W / 2 + T
                }
            },
            cubicin: function (U, T, W, V) {
                return W * (U /= V) * U * U + T
            },
            cubicout: function (U, T, W, V) {
                return W * ((U = U / V - 1) * U * U + 1) + T
            },
            cubicinout: function (U, T, W, V) {
                if ((U /= V / 2) < 1) {
                    return W / 2 * U * U * U + T
                }
                return W / 2 * ((U -= 2) * U * U + 2) + T
            },
            elasticin: function (V, T, Z, Y, U, X) {
                var W;
                if (V == 0) {
                    return T
                }
                if ((V /= Y) == 1) {
                    return T + Z
                }
                if (!X) {
                    X = Y * 0.3
                }
                if (!U || U < S(Z)) {
                    U = Z;
                    W = X / 4
                } else {
                    W = X / J * L(Z / U)
                }
                return -(U * M(2, 10 * (V -= 1)) * P((V * Y - W) * J / X)) + T
            },
            elasticout: function (V, T, Z, Y, U, X) {
                var W;
                if (V == 0) {
                    return T
                }
                if ((V /= Y) == 1) {
                    return T + Z
                }
                if (!X) {
                    X = Y * 0.3
                }
                if (!U || U < S(Z)) {
                    U = Z;
                    W = X / 4
                } else {
                    W = X / J * L(Z / U)
                }
                return (U * M(2, -10 * V) * P((V * Y - W) * J / X) + Z + T)
            },
            elasticinout: function (V, T, Z, Y, U, X) {
                var W;
                if (V == 0) {
                    return T
                }
                if ((V /= Y / 2) == 2) {
                    return T + Z
                }
                if (!X) {
                    X = Y * (0.3 * 1.5)
                }
                if (!U || U < S(Z)) {
                    U = Z;
                    W = X / 4
                } else {
                    W = X / J * L(Z / U)
                }
                if (V < 1) {
                    return -0.5 * (U * M(2, 10 * (V -= 1)) * P((V * Y - W) * J / X)) + T
                }
                return U * M(2, -10 * (V -= 1)) * P((V * Y - W) * J / X) * 0.5 + Z + T
            },
            quadin: function (U, T, W, V) {
                return W * (U /= V) * U + T
            },
            quadout: function (U, T, W, V) {
                return -W * (U /= V) * (U - 2) + T
            },
            quadinout: function (U, T, W, V) {
                if ((U /= V / 2) < 1) {
                    return W / 2 * U * U + T
                }
                return -W / 2 * ((--U) * (U - 2) - 1) + T
            },
            sinein: function (U, T, W, V) {
                return -W * Q(U / V * O) + W + T
            },
            sineout: function (U, T, W, V) {
                return W * P(U / V * O) + T
            },
            sineinout: function (U, T, W, V) {
                return -W / 2 * (Q(Math.PI * U / V) - 1) + T
            }
        };
        return (K[N]) ? K[N] : K.linear
    };
    D.Core.MapAnimator = function (J) {
        this.map = J
    };
    D.Core.MapAnimator.prototype = {
        loadAnimation: function (J) {
            this.animation = J
        },
        play: function () {
            this.startTime = new Date().getTime();
            var J = this.getNextIdx();
            setTimeout(this.step.bind(this), J)
        },
        step: function () {
            var J = new Date().getTime() - this.startTime;
            var N = this.getNextIdx();
            if (!N) {
                return
            }
            var O = this.animation[N];
            for (var L = 0; L < O.length; L++) {
                var M = O[L];
                this.runItem(M)
            }
            delete this.animation[N];
            var K = this.getNextIdx();
            setTimeout(this.step.bind(this), K - J)
        },
        runItem: function (J) {
            switch (J.type) {
                case "zoom":
                    this.zoomAnimator = new D.Core.ZoomAnimator({
                        start: this.map.zoom,
                        end: J.target,
                        duration: J.duration,
                        easing: J.easing,
                        onStep: function (K) {
                            this.map.zoom = K;
                            this.map.render()
                        }.bind(this)
                    });
                    break;
                case "position":
                    this.positionAnimator = new D.Core.PositionAnimator({
                        start: this.map.center,
                        end: new D.Core.Position(J.target),
                        duration: J.duration,
                        easing: J.easing,
                        onStep: function (K) {
                            this.map.centerOn(K, {
                                animated: false
                            })
                        }.bind(this)
                    });
                    break;
                case "config":
                    D.Core.Configuration.defaultConfig = J.target;
                    D.Core.Configuration.defaultHiResConfig = J.target;
                    break
            }
        },
        getNextIdx: function () {
            for (i in this.animation) {
                var J = i;
                return J
            }
            return false
        }
    };
    D.Core.HTMLRenderer = function (J) {
        this.container = J;
        this.imageWrapper = D.crEl("div");
        this.imageWrapper.style.position = "absolute";
        this.imageWrapper.style.overflow = "hidden";
        this.imageWrapper.style.top = this.imageWrapper.style.left = 0;
        this.resize();
        this.container.appendChild(this.imageWrapper);
        this.images = [];
        this.bmark = {
            counts: 0,
            renderTime: 0
        };
        this.scale = D.Window.getDpr()
    };
    D.Core.HTMLRenderer.prototype = {
        resize: function () {
            this.imageWrapper.style.width = this.container.style.width;
            this.imageWrapper.style.height = this.container.style.height
        },
        render: function (J) {
            this.renderRestore(J)
        },
        show: function () {
            this.imageWrapper.style.display = "block"
        },
        hide: function () {
            this.imageWrapper.style.display = "none"
        },
        renderRestore: function (O) {
            var L = D.Utilities.removeElementToReinsert(this.imageWrapper);
            var N = this.imageWrapper;
            N.innerHTML = "";
            var M = new Date().getTime();
            for (var K = 0; K < O.length; K++) {
                var J = O[K];
                J.img.className = "deCarta-Core-TileImage";
                if (J.img.empty) {
                    J.img.className += " blank"
                }
                J.img.style.position = "absolute";
                J.y = Math.floor(J.y);
                J.x = Math.floor(J.x);
                J.size = Math.ceil(J.size);
                J.img.style.top = J.y + "px";
                J.img.style.left = J.x + "px";
                J.img.style.width = J.img.style.height = J.size + "px";
                J.img.style.zIndex = 10 - (J.scale);
                N.appendChild(J.img)
            }
            L()
        },
        renderReplace: function (M) {
            var L = D.crEl("div");
            for (var K = 0; K < M.length; K++) {
                var J = M[K];
                J.img.className = "deCarta-mobile-tileImage";
                if (J.img.empty) {
                    J.img.className += " blank"
                }
                J.img.style.position = "absolute";
                J.y = Math.floor(J.y);
                J.x = Math.floor(J.x);
                J.size = Math.ceil(J.size);
                J.img.style.top = J.y + "px";
                J.img.style.left = J.x + "px";
                J.img.style.width = J.img.style.height = J.size + "px";
                L.appendChild(J.img)
            }
            this.imageWrapper.parentNode.replaceChild(L, this.imageWrapper);
            this.imageWrapper = L
        },
        renderString: function (N) {
            var M = D.crEl("div");
            var K = "";
            for (var L = 0; L < N.length; L++) {
                var J = N[L];
                K += '<img src="' + J.img.src + '" class="deCarta-mobile-tileImage ' + (J.img.empty ? "blank" : "") + '" style="position: absolute; top: ' + Math.floor(J.y) + "px; left: " + Math.floor(J.x) + "px; width: " + Math.ceil(J.size) + "px; height: " + Math.ceil(J.size) + ' " />'
            }
            M.innerHTML = K;
            this.imageWrapper.parentNode.replaceChild(M, this.imageWrapper);
            this.imageWrapper = M
        }
    };
    D.Core.CSS3Renderer = function (J) {
        this.container = J;
        this.imageWrapper = D.crEl("div");
        this.imageWrapper.style.position = "absolute";
        this.imageWrapper.style.overflow = "hidden";
        this.imageWrapper.style.top = this.imageWrapper.style.left = 0;
        this.resize();
        this.resetCounter = 0;
        this.container.appendChild(this.imageWrapper);
        this.images = [];
        this.visibleKeys = {};
        this.imageWrapper.id = "deCarta-Core-Renderer-" + Math.floor(Math.random() * 10000);
        this.id = 0;
        this.scale = D.Window.getDpr()
    };
    D.Core.CSS3Renderer.prototype = {
        resize: function () {
            this.imageWrapper.style.width = this.container.style.width;
            this.imageWrapper.style.height = this.container.style.height
        },
        render: function (Q) {
            if (this.resetCounter >= 100) {
                this.imageWrapper.innerHTML = "";
                this.visibleKeys = {};
                this.resetCounter = 0
            }
            var N = {};
            for (var L = 0; L < Q.length; L++) {
                var J = Q[L];
                J.img.className = "deCarta-Core-TileImage";
                if (J.img.empty) {
                    J.img.className += " blank"
                }
                J.img.style.position = "absolute";
                var P = J.size / J.img.width;
                if (P == 1) {
                    J.y = Math.floor(J.y);
                    J.x = Math.floor(J.x);
                    J.width = Math.ceil(J.width);
                    J.height = Math.ceil(J.height)
                }
                J.img.style.top = "0px";
                J.img.style.left = "0px";
                J.img.style.webkitTransformOrigin = " 0 0 ";
                J.img.style.MozTransformOrigin = " 0 0 ";
                J.img.style.OTransformOrigin = " 0 0 ";
                J.img.style.msTransformOrigin = " 0 0 ";
                J.img.style.TransformOrigin = " 0 0 ";
                J.img.style.webkitTransform = "translate3d(" + J.x + "px, " + J.y + "px, 0) scale(" + P + ") ";
                J.img.style.MozTransform = "translate3d(" + J.x + "px, " + J.y + "px, 0) scale(" + P + ") ";
                J.img.style.OTransform = "translate3d(" + J.x + "px, " + J.y + "px, 0) scale(" + P + ") ";
                J.img.style.msTransform = "translate3d(" + J.x + "px, " + J.y + "px, 0) scale(" + P + ") ";
                J.img.style.Transform = "translate3d(" + J.x + "px, " + J.y + "px, 0) scale(" + P + ") ";
                J.img.style.zIndex = 10 - (J.scale);
                if (!J.img.parentNode) {
                    J.img.id = this.imageWrapper.id + "_" + this.id++;
                    this.imageWrapper.appendChild(J.img);
                    this.visibleKeys[J.img.key] = J.img.id
                }
                N[J.img.key] = J.img.id
            }
            for (var K in this.visibleKeys) {
                if (!N[K]) {
                    try {
                        var M = D.geId(this.visibleKeys[K]);
                        M.parentNode.removeChild(M);
                        this.visibleKeys[K] = false;
                        delete this.visibleKeys[K]
                    } catch (O) {
                        console.log("CSS3Renderer", O, N[K], K)
                    }
                }
            }
            this.resetCounter++
        },
        show: function () {
            this.imageWrapper.style.display = "block"
        },
        hide: function () {
            this.imageWrapper.style.display = "none"
        }
    };
    G.deCarta = D;
    G._dC = D.Core;
    G._dU = D.Utilities;
    D.Mobile = D.Core;
    D.Mobile.ZoomControl = D.UI.ZoomControl;
    D.Mobile.PanControl = D.UI.PanControl;
    D.Mobile.CopyrightControl = D.UI.CopyrightControl
})(window);